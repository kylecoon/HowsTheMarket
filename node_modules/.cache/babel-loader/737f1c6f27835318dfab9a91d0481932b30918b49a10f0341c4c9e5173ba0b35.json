{"ast":null,"code":"/**\n * chartjs-chart-geo\n * https://github.com/sgratzl/chartjs-chart-geo\n *\n * Copyright (c) 2019-2023 Samuel Gratzl <sam@sgratzl.com>\n */\n\nimport { Scale, LinearScale, LogarithmicScale, Element, BarElement, DatasetController, registry, Chart, PointElement } from 'chart.js';\nimport { geoNaturalEarth1, geoTransverseMercator, geoMercator, geoEquirectangular, geoConicEquidistant, geoConicEqualArea, geoConicConformal, geoAlbersUsa, geoAlbers, geoEqualEarth, geoStereographic, geoOrthographic, geoGnomonic, geoAzimuthalEquidistant, geoAzimuthalEqualArea, geoPath, geoContains, geoGraticule10, geoGraticule } from 'd3-geo';\nexport { geoAlbers, geoAlbersUsa, geoAzimuthalEqualArea, geoAzimuthalEquidistant, geoConicConformal, geoConicEqualArea, geoConicEquidistant, geoEqualEarth, geoEquirectangular, geoGnomonic, geoMercator, geoNaturalEarth1, geoOrthographic, geoStereographic, geoTransverseMercator } from 'd3-geo';\nimport { merge, drawPoint, valueOrDefault, clipArea, unclipArea } from 'chart.js/helpers';\nimport { interpolateYlOrRd, interpolateYlOrBr, interpolateYlGnBu, interpolateYlGn, interpolateWarm, interpolateViridis, interpolateTurbo, interpolateSpectral, interpolateSinebow, interpolateReds, interpolateRdYlGn, interpolateRdYlBu, interpolateRdPu, interpolateRdGy, interpolateRdBu, interpolateRainbow, interpolatePurples, interpolatePuRd, interpolatePuOr, interpolatePuBuGn, interpolatePuBu, interpolatePlasma, interpolatePiYG, interpolatePRGn, interpolateOranges, interpolateOrRd, interpolateMagma, interpolateInferno, interpolateGreys, interpolateGreens, interpolateGnBu, interpolateCubehelixDefault, interpolateCool, interpolateCividis, interpolateBuPu, interpolateBuGn, interpolateBrBG, interpolateBlues } from 'd3-scale-chromatic';\nimport * as topojsonClient from 'topojson-client';\nexport { topojsonClient as topojson };\nconst lookup$1 = {\n  geoAzimuthalEqualArea,\n  geoAzimuthalEquidistant,\n  geoGnomonic,\n  geoOrthographic,\n  geoStereographic,\n  geoEqualEarth,\n  geoAlbers,\n  geoAlbersUsa,\n  geoConicConformal,\n  geoConicEqualArea,\n  geoConicEquidistant,\n  geoEquirectangular,\n  geoMercator,\n  geoTransverseMercator,\n  geoNaturalEarth1\n};\nObject.keys(lookup$1).forEach(key => {\n  lookup$1[`${key.charAt(3).toLowerCase()}${key.slice(4)}`] = lookup$1[key];\n});\nclass ProjectionScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.outlineBounds = null;\n    this.oldChartBounds = null;\n    this.geoPath = geoPath();\n  }\n  init(options) {\n    options.position = 'chartArea';\n    super.init(options);\n    if (typeof options.projection === 'function') {\n      this.projection = options.projection;\n    } else {\n      this.projection = (lookup$1[options.projection] || lookup$1.albersUsa)();\n    }\n    this.geoPath.projection(this.projection);\n    this.outlineBounds = null;\n    this.oldChartBounds = null;\n  }\n  computeBounds(outline) {\n    const bb = geoPath(this.projection.fitWidth(1000, outline)).bounds(outline);\n    const bHeight = Math.ceil(bb[1][1] - bb[0][1]);\n    const bWidth = Math.ceil(bb[1][0] - bb[0][0]);\n    const t = this.projection.translate();\n    this.outlineBounds = {\n      width: bWidth,\n      height: bHeight,\n      aspectRatio: bWidth / bHeight,\n      refScale: this.projection.scale(),\n      refX: t[0],\n      refY: t[1]\n    };\n  }\n  updateBounds() {\n    const area = this.chart.chartArea;\n    const bb = this.outlineBounds;\n    if (!bb) {\n      return false;\n    }\n    const padding = this.options.padding;\n    const paddingTop = typeof padding === 'number' ? padding : padding.top;\n    const paddingLeft = typeof padding === 'number' ? padding : padding.left;\n    const paddingBottom = typeof padding === 'number' ? padding : padding.bottom;\n    const paddingRight = typeof padding === 'number' ? padding : padding.right;\n    const chartWidth = area.right - area.left - paddingLeft - paddingRight;\n    const chartHeight = area.bottom - area.top - paddingTop - paddingBottom;\n    const bak = this.oldChartBounds;\n    this.oldChartBounds = {\n      chartWidth,\n      chartHeight\n    };\n    const scale = Math.min(chartWidth / bb.width, chartHeight / bb.height);\n    const viewWidth = bb.width * scale;\n    const viewHeight = bb.height * scale;\n    const x = (chartWidth - viewWidth) * 0.5 + area.left + paddingLeft;\n    const y = (chartHeight - viewHeight) * 0.5 + area.top + paddingTop;\n    const o = this.options;\n    this.projection.scale(bb.refScale * scale * o.projectionScale).translate([scale * bb.refX + x + o.projectionOffset[0], scale * bb.refY + y + o.projectionOffset[1]]);\n    return !bak || bak.chartWidth !== this.oldChartBounds.chartWidth || bak.chartHeight !== this.oldChartBounds.chartHeight;\n  }\n}\nProjectionScale.id = 'projection';\nProjectionScale.defaults = {\n  projection: 'albersUsa',\n  projectionScale: 1,\n  projectionOffset: [0, 0],\n  padding: 0\n};\nProjectionScale.descriptors = {\n  _scriptable: name => name !== 'projection',\n  _indexable: name => name !== 'projectionOffset'\n};\nconst baseDefaults = {\n  position: 'chartArea',\n  property: 'value',\n  grid: {\n    z: 1,\n    drawOnChartArea: false\n  },\n  ticks: {\n    z: 1\n  },\n  legend: {\n    align: 'right',\n    position: 'bottom-right',\n    length: 100,\n    width: 50,\n    margin: 8,\n    indicatorWidth: 10\n  }\n};\nfunction computeLegendMargin(legend) {\n  const {\n    indicatorWidth,\n    align: pos,\n    margin\n  } = legend;\n  const left = (typeof margin === 'number' ? margin : margin.left) + (pos === 'right' ? indicatorWidth : 0);\n  const top = (typeof margin === 'number' ? margin : margin.top) + (pos === 'bottom' ? indicatorWidth : 0);\n  const right = (typeof margin === 'number' ? margin : margin.right) + (pos === 'left' ? indicatorWidth : 0);\n  const bottom = (typeof margin === 'number' ? margin : margin.bottom) + (pos === 'top' ? indicatorWidth : 0);\n  return {\n    left,\n    top,\n    right,\n    bottom\n  };\n}\nfunction computeLegendPosition(chartArea, legend, width, height, legendSize) {\n  const {\n    indicatorWidth,\n    align: axisPos,\n    position: pos\n  } = legend;\n  const isHor = axisPos === 'top' || axisPos === 'bottom';\n  const w = (axisPos === 'left' ? legendSize.w : width) + (isHor ? indicatorWidth : 0);\n  const h = (axisPos === 'top' ? legendSize.h : height) + (!isHor ? indicatorWidth : 0);\n  const margin = computeLegendMargin(legend);\n  if (typeof pos === 'string') {\n    switch (pos) {\n      case 'top-left':\n        return [margin.left, margin.top];\n      case 'top':\n        return [(chartArea.right - w) / 2, margin.top];\n      case 'left':\n        return [margin.left, (chartArea.bottom - h) / 2];\n      case 'top-right':\n        return [chartArea.right - w - margin.right, margin.top];\n      case 'bottom-right':\n        return [chartArea.right - w - margin.right, chartArea.bottom - h - margin.bottom];\n      case 'bottom':\n        return [(chartArea.right - w) / 2, chartArea.bottom - h - margin.bottom];\n      case 'bottom-left':\n        return [margin.left, chartArea.bottom - h - margin.bottom];\n      default:\n        return [chartArea.right - w - margin.right, (chartArea.bottom - h) / 2];\n    }\n  }\n  return [pos.x, pos.y];\n}\nclass LegendScale extends LinearScale {\n  constructor() {\n    super(...arguments);\n    this.legendSize = {\n      w: 0,\n      h: 0\n    };\n  }\n  init(options) {\n    options.position = 'chartArea';\n    super.init(options);\n    this.axis = 'r';\n  }\n  parse(raw, index) {\n    if (raw && typeof raw[this.options.property] === 'number') {\n      return raw[this.options.property];\n    }\n    return super.parse(raw, index);\n  }\n  isHorizontal() {\n    return this.options.legend.align === 'top' || this.options.legend.align === 'bottom';\n  }\n  _getNormalizedValue(v) {\n    if (v == null || Number.isNaN(v)) {\n      return null;\n    }\n    return (v - this._startValue) / this._valueRange;\n  }\n  update(maxWidth, maxHeight, margins) {\n    const ch = Math.min(maxHeight, this.bottom == null ? Number.POSITIVE_INFINITY : this.bottom);\n    const cw = Math.min(maxWidth, this.right == null ? Number.POSITIVE_INFINITY : this.right);\n    const l = this.options.legend;\n    const isHor = this.isHorizontal();\n    const factor = (v, full) => v < 1 ? full * v : v;\n    const w = Math.min(cw, factor(isHor ? l.length : l.width, cw)) - (!isHor ? l.indicatorWidth : 0);\n    const h = Math.min(ch, factor(!isHor ? l.length : l.width, ch)) - (isHor ? l.indicatorWidth : 0);\n    this.legendSize = {\n      w,\n      h\n    };\n    this.bottom = h;\n    this.height = h;\n    this.right = w;\n    this.width = w;\n    const bak = this.options.position;\n    this.options.position = this.options.legend.align;\n    const r = super.update(w, h, margins);\n    this.options.position = bak;\n    this.height = Math.min(h, this.height);\n    this.width = Math.min(w, this.width);\n    return r;\n  }\n  _computeLabelArea() {\n    return undefined;\n  }\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n    const pos = computeLegendPosition(chartArea, this.options.legend, this.width, this.height, this.legendSize);\n    const {\n      ctx\n    } = this;\n    ctx.save();\n    ctx.translate(pos[0], pos[1]);\n    const bak = this.options.position;\n    this.options.position = this.options.legend.align;\n    super.draw({\n      ...chartArea,\n      bottom: this.height + 10,\n      right: this.width\n    });\n    this.options.position = bak;\n    const {\n      indicatorWidth\n    } = this.options.legend;\n    switch (this.options.legend.align) {\n      case 'left':\n        ctx.translate(this.legendSize.w, 0);\n        break;\n      case 'top':\n        ctx.translate(0, this.legendSize.h);\n        break;\n      case 'bottom':\n        ctx.translate(0, -indicatorWidth);\n        break;\n      default:\n        ctx.translate(-indicatorWidth, 0);\n        break;\n    }\n    this._drawIndicator();\n    ctx.restore();\n  }\n  _drawIndicator() {}\n}\nclass LogarithmicLegendScale extends LogarithmicScale {\n  constructor() {\n    super(...arguments);\n    this.legendSize = {\n      w: 0,\n      h: 0\n    };\n  }\n  init(options) {\n    LegendScale.prototype.init.call(this, options);\n  }\n  parse(raw, index) {\n    return LegendScale.prototype.parse.call(this, raw, index);\n  }\n  isHorizontal() {\n    return this.options.legend.align === 'top' || this.options.legend.align === 'bottom';\n  }\n  _getNormalizedValue(v) {\n    if (v == null || Number.isNaN(v)) {\n      return null;\n    }\n    return (Math.log10(v) - this._startValue) / this._valueRange;\n  }\n  update(maxWidth, maxHeight, margins) {\n    return LegendScale.prototype.update.call(this, maxWidth, maxHeight, margins);\n  }\n  _computeLabelArea() {\n    return undefined;\n  }\n  draw(chartArea) {\n    return LegendScale.prototype.draw.call(this, chartArea);\n  }\n  _drawIndicator() {}\n}\nconst lookup = {\n  interpolateBlues,\n  interpolateBrBG,\n  interpolateBuGn,\n  interpolateBuPu,\n  interpolateCividis,\n  interpolateCool,\n  interpolateCubehelixDefault,\n  interpolateGnBu,\n  interpolateGreens,\n  interpolateGreys,\n  interpolateInferno,\n  interpolateMagma,\n  interpolateOrRd,\n  interpolateOranges,\n  interpolatePRGn,\n  interpolatePiYG,\n  interpolatePlasma,\n  interpolatePuBu,\n  interpolatePuBuGn,\n  interpolatePuOr,\n  interpolatePuRd,\n  interpolatePurples,\n  interpolateRainbow,\n  interpolateRdBu,\n  interpolateRdGy,\n  interpolateRdPu,\n  interpolateRdYlBu,\n  interpolateRdYlGn,\n  interpolateReds,\n  interpolateSinebow,\n  interpolateSpectral,\n  interpolateTurbo,\n  interpolateViridis,\n  interpolateWarm,\n  interpolateYlGn,\n  interpolateYlGnBu,\n  interpolateYlOrBr,\n  interpolateYlOrRd\n};\nObject.keys(lookup).forEach(key => {\n  lookup[`${key.charAt(11).toLowerCase()}${key.slice(12)}`] = lookup[key];\n  lookup[key.slice(11)] = lookup[key];\n});\nfunction quantize(v, steps) {\n  const perStep = 1 / steps;\n  if (v <= perStep) {\n    return 0;\n  }\n  if (v >= 1 - perStep) {\n    return 1;\n  }\n  for (let acc = 0; acc < 1; acc += perStep) {\n    if (v < acc) {\n      return acc - perStep / 2;\n    }\n  }\n  return v;\n}\nconst colorScaleDefaults = {\n  interpolate: 'blues',\n  missing: 'transparent',\n  quantize: 0\n};\nclass ColorScale extends LegendScale {\n  get interpolate() {\n    const o = this.options;\n    if (!o) {\n      return v => `rgb(${v},${v},${v})`;\n    }\n    if (typeof o.interpolate === 'function') {\n      return o.interpolate;\n    }\n    return lookup[o.interpolate] || lookup.blues;\n  }\n  getColorForValue(value) {\n    const v = this._getNormalizedValue(value);\n    if (v == null || Number.isNaN(v)) {\n      return this.options.missing;\n    }\n    return this.getColor(v);\n  }\n  getColor(normalized) {\n    let v = normalized;\n    if (this.options.quantize > 0) {\n      v = quantize(v, this.options.quantize);\n    }\n    return this.interpolate(v);\n  }\n  _drawIndicator() {\n    const {\n      indicatorWidth: indicatorSize\n    } = this.options.legend;\n    const reverse = this._reversePixels;\n    if (this.isHorizontal()) {\n      const w = this.width;\n      if (this.options.quantize > 0) {\n        const stepWidth = w / this.options.quantize;\n        const offset = !reverse ? i => i : i => w - stepWidth - i;\n        for (let i = 0; i < w; i += stepWidth) {\n          const v = (i + stepWidth / 2) / w;\n          this.ctx.fillStyle = this.getColor(v);\n          this.ctx.fillRect(offset(i), 0, stepWidth, indicatorSize);\n        }\n      } else {\n        const offset = !reverse ? i => i : i => w - 1 - i;\n        for (let i = 0; i < w; i += 1) {\n          this.ctx.fillStyle = this.getColor((i + 0.5) / w);\n          this.ctx.fillRect(offset(i), 0, 1, indicatorSize);\n        }\n      }\n    } else {\n      const h = this.height;\n      if (this.options.quantize > 0) {\n        const stepWidth = h / this.options.quantize;\n        const offset = !reverse ? i => i : i => h - stepWidth - i;\n        for (let i = 0; i < h; i += stepWidth) {\n          const v = (i + stepWidth / 2) / h;\n          this.ctx.fillStyle = this.getColor(v);\n          this.ctx.fillRect(0, offset(i), indicatorSize, stepWidth);\n        }\n      } else {\n        const offset = !reverse ? i => i : i => h - 1 - i;\n        for (let i = 0; i < h; i += 1) {\n          this.ctx.fillStyle = this.getColor((i + 0.5) / h);\n          this.ctx.fillRect(0, offset(i), indicatorSize, 1);\n        }\n      }\n    }\n  }\n}\nColorScale.id = 'color';\nColorScale.defaults = merge({}, [LinearScale.defaults, baseDefaults, colorScaleDefaults]);\nColorScale.descriptors = {\n  _scriptable: name => name !== 'interpolate',\n  _indexable: false\n};\nclass ColorLogarithmicScale extends LogarithmicLegendScale {\n  constructor() {\n    super(...arguments);\n    this.interpolate = v => `rgb(${v},${v},${v})`;\n  }\n  init(options) {\n    super.init(options);\n    if (typeof options.interpolate === 'function') {\n      this.interpolate = options.interpolate;\n    } else {\n      this.interpolate = lookup[options.interpolate] || lookup.blues;\n    }\n  }\n  getColorForValue(value) {\n    return ColorScale.prototype.getColorForValue.call(this, value);\n  }\n  getColor(normalized) {\n    let v = normalized;\n    if (this.options.quantize > 0) {\n      v = quantize(v, this.options.quantize);\n    }\n    return this.interpolate(v);\n  }\n  _drawIndicator() {\n    return ColorScale.prototype._drawIndicator.call(this);\n  }\n}\nColorLogarithmicScale.id = 'colorLogarithmic';\nColorLogarithmicScale.defaults = merge({}, [LogarithmicScale.defaults, baseDefaults, colorScaleDefaults]);\nColorLogarithmicScale.descriptors = {\n  _scriptable: name => name !== 'interpolate',\n  _indexable: false\n};\nconst scaleDefaults = {\n  missing: 1,\n  mode: 'area',\n  range: [2, 20],\n  legend: {\n    align: 'bottom',\n    length: 90,\n    width: 70,\n    indicatorWidth: 42\n  }\n};\nclass SizeScale extends LegendScale {\n  constructor() {\n    super(...arguments);\n    this._model = null;\n  }\n  getSizeForValue(value) {\n    const v = this._getNormalizedValue(value);\n    if (v == null || Number.isNaN(v)) {\n      return this.options.missing;\n    }\n    return this.getSizeImpl(v);\n  }\n  getSizeImpl(normalized) {\n    const [r0, r1] = this.options.range;\n    if (this.options.mode === 'area') {\n      const a1 = r1 * r1 * Math.PI;\n      const a0 = r0 * r0 * Math.PI;\n      const range = a1 - a0;\n      const a = normalized * range + a0;\n      return Math.sqrt(a / Math.PI);\n    }\n    const range = r1 - r0;\n    return normalized * range + r0;\n  }\n  _drawIndicator() {\n    const {\n      ctx\n    } = this;\n    const shift = this.options.legend.indicatorWidth / 2;\n    const isHor = this.isHorizontal();\n    const values = this.ticks;\n    const labelItems = this.getLabelItems();\n    const positions = labelItems ? labelItems.map(el => ({\n      [isHor ? 'x' : 'y']: el.options.translation[isHor ? 0 : 1]\n    })) : values.map((_, i) => ({\n      [isHor ? 'x' : 'y']: this.getPixelForTick(i)\n    }));\n    (this._gridLineItems || []).forEach(item => {\n      ctx.save();\n      ctx.strokeStyle = item.color;\n      ctx.lineWidth = item.width;\n      if (ctx.setLineDash) {\n        ctx.setLineDash(item.borderDash);\n        ctx.lineDashOffset = item.borderDashOffset;\n      }\n      ctx.beginPath();\n      if (this.options.grid.drawTicks) {\n        switch (this.options.legend.align) {\n          case 'left':\n            ctx.moveTo(0, item.ty1);\n            ctx.lineTo(shift, item.ty2);\n            break;\n          case 'top':\n            ctx.moveTo(item.tx1, 0);\n            ctx.lineTo(item.tx2, shift);\n            break;\n          case 'bottom':\n            ctx.moveTo(item.tx1, shift);\n            ctx.lineTo(item.tx2, shift * 2);\n            break;\n          default:\n            ctx.moveTo(shift, item.ty1);\n            ctx.lineTo(shift * 2, item.ty2);\n            break;\n        }\n      }\n      ctx.stroke();\n      ctx.restore();\n    });\n    if (this._model) {\n      const props = this._model;\n      ctx.strokeStyle = props.borderColor;\n      ctx.lineWidth = props.borderWidth || 0;\n      ctx.fillStyle = props.backgroundColor;\n    } else {\n      ctx.fillStyle = 'blue';\n    }\n    values.forEach((v, i) => {\n      const pos = positions[i];\n      const radius = this.getSizeForValue(v.value);\n      const x = isHor ? pos.x : shift;\n      const y = isHor ? shift : pos.y;\n      const renderOptions = {\n        pointStyle: 'circle',\n        borderWidth: 0,\n        ...(this._model || {}),\n        radius\n      };\n      drawPoint(ctx, renderOptions, x, y);\n    });\n  }\n}\nSizeScale.id = 'size';\nSizeScale.defaults = merge({}, [LinearScale.defaults, baseDefaults, scaleDefaults]);\nSizeScale.descriptors = {\n  _scriptable: true,\n  _indexable: name => name !== 'range'\n};\nclass SizeLogarithmicScale extends LogarithmicLegendScale {\n  constructor() {\n    super(...arguments);\n    this._model = null;\n  }\n  getSizeForValue(value) {\n    const v = this._getNormalizedValue(value);\n    if (v == null || Number.isNaN(v)) {\n      return this.options.missing;\n    }\n    return this.getSizeImpl(v);\n  }\n  getSizeImpl(normalized) {\n    return SizeScale.prototype.getSizeImpl.call(this, normalized);\n  }\n  _drawIndicator() {\n    SizeScale.prototype._drawIndicator.call(this);\n  }\n}\nSizeLogarithmicScale.id = 'sizeLogarithmic';\nSizeLogarithmicScale.defaults = merge({}, [LogarithmicScale.defaults, baseDefaults, scaleDefaults]);\nfunction growGeoBounds(bounds, amount) {\n  return [[bounds[0][0] - amount, bounds[0][1] - amount], [bounds[1][0] + amount, bounds[1][1] + amount]];\n}\nclass GeoFeature extends Element {\n  constructor() {\n    super(...arguments);\n    this.cache = undefined;\n  }\n  inRange(mouseX, mouseY) {\n    const bb = this.getBounds();\n    const r = (Number.isNaN(mouseX) || mouseX >= bb.x && mouseX <= bb.x2) && (Number.isNaN(mouseY) || mouseY >= bb.y && mouseY <= bb.y2);\n    const projection = this.projectionScale.geoPath.projection();\n    if (r && !Number.isNaN(mouseX) && !Number.isNaN(mouseY) && typeof projection.invert === 'function') {\n      const longLat = projection.invert([mouseX, mouseY]);\n      return longLat != null && geoContains(this.feature, longLat);\n    }\n    return r;\n  }\n  inXRange(mouseX) {\n    return this.inRange(mouseX, Number.NaN);\n  }\n  inYRange(mouseY) {\n    return this.inRange(Number.NaN, mouseY);\n  }\n  getCenterPoint() {\n    if (this.cache && this.cache.center) {\n      return this.cache.center;\n    }\n    let center;\n    if (this.center) {\n      const p = this.projectionScale.projection([this.center.longitude, this.center.latitude]);\n      center = {\n        x: p[0],\n        y: p[1]\n      };\n    } else {\n      const centroid = this.projectionScale.geoPath.centroid(this.feature);\n      center = {\n        x: centroid[0],\n        y: centroid[1]\n      };\n    }\n    this.cache = {\n      ...(this.cache || {}),\n      center\n    };\n    return center;\n  }\n  getBounds() {\n    if (this.cache && this.cache.bounds) {\n      return this.cache.bounds;\n    }\n    const bb = growGeoBounds(this.projectionScale.geoPath.bounds(this.feature), this.options.borderWidth / 2);\n    const bounds = {\n      x: bb[0][0],\n      x2: bb[1][0],\n      y: bb[0][1],\n      y2: bb[1][1],\n      width: bb[1][0] - bb[0][0],\n      height: bb[1][1] - bb[0][1]\n    };\n    this.cache = {\n      ...(this.cache || {}),\n      bounds\n    };\n    return bounds;\n  }\n  _drawInCache(doc) {\n    const bounds = this.getBounds();\n    if (!Number.isFinite(bounds.x)) {\n      return;\n    }\n    const canvas = this.cache && this.cache.canvas ? this.cache.canvas : doc.createElement('canvas');\n    const x1 = Math.floor(bounds.x);\n    const y1 = Math.floor(bounds.y);\n    const x2 = Math.ceil(bounds.x + bounds.width);\n    const y2 = Math.ceil(bounds.y + bounds.height);\n    const pixelRatio = this.pixelRatio || 1;\n    const width = Math.ceil(Math.max(x2 - x1, 1) * pixelRatio);\n    const height = Math.ceil(Math.max(y2 - y1, 1) * pixelRatio);\n    if (width <= 0 || height <= 0) {\n      return;\n    }\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.save();\n      ctx.scale(pixelRatio, pixelRatio);\n      ctx.translate(-x1, -y1);\n      this._drawImpl(ctx);\n      ctx.restore();\n      this.cache = {\n        ...(this.cache || {}),\n        canvas,\n        canvasKey: this._optionsToKey()\n      };\n    }\n  }\n  _optionsToKey() {\n    const {\n      options\n    } = this;\n    return `${options.backgroundColor};${options.borderColor};${options.borderWidth};${this.pixelRatio}`;\n  }\n  _drawImpl(ctx) {\n    const {\n      feature\n    } = this;\n    const {\n      options\n    } = this;\n    ctx.beginPath();\n    this.projectionScale.geoPath.context(ctx)(feature);\n    if (options.backgroundColor) {\n      ctx.fillStyle = options.backgroundColor;\n      ctx.fill();\n    }\n    if (options.borderColor) {\n      ctx.strokeStyle = options.borderColor;\n      ctx.lineWidth = options.borderWidth;\n      ctx.stroke();\n    }\n  }\n  draw(ctx) {\n    const {\n      feature\n    } = this;\n    if (!feature) {\n      return;\n    }\n    if ((!this.cache || this.cache.canvasKey !== this._optionsToKey()) && ctx.canvas.ownerDocument != null) {\n      this._drawInCache(ctx.canvas.ownerDocument);\n    }\n    const bounds = this.getBounds();\n    if (this.cache && this.cache.canvas && this.cache.canvas.width > 0 && this.cache.canvas.height > 0) {\n      const x1 = Math.floor(bounds.x);\n      const y1 = Math.floor(bounds.y);\n      const x2 = Math.ceil(bounds.x + bounds.width);\n      const y2 = Math.ceil(bounds.y + bounds.height);\n      const width = x2 - x1;\n      const height = y2 - y1;\n      if (width > 0 && height > 0) {\n        ctx.drawImage(this.cache.canvas, x1, y1, x2 - x1, y2 - y1);\n      }\n    } else if (Number.isFinite(bounds.x)) {\n      ctx.save();\n      this._drawImpl(ctx);\n      ctx.restore();\n    }\n  }\n}\nGeoFeature.id = 'geoFeature';\nGeoFeature.defaults = {\n  ...BarElement.defaults,\n  outlineBackgroundColor: null,\n  outlineBorderWidth: 0,\n  graticuleBorderColor: '#CCCCCC',\n  graticuleBorderWidth: 0\n};\nGeoFeature.defaultRoutes = {\n  outlineBorderColor: 'borderColor',\n  ...(BarElement.defaultRoutes || {})\n};\nconst geoDefaults = {\n  showOutline: false,\n  showGraticule: false,\n  clipMap: true\n};\nconst geoOverrides = {\n  scales: {\n    projection: {\n      axis: 'x',\n      type: ProjectionScale.id,\n      position: 'chartArea',\n      display: false\n    }\n  }\n};\nfunction patchDatasetElementOptions(options) {\n  const r = {\n    ...options\n  };\n  Object.keys(options).forEach(key => {\n    let targetKey = key;\n    if (key.startsWith('outline')) {\n      const sub = key.slice('outline'.length);\n      targetKey = sub[0].toLowerCase() + sub.slice(1);\n    } else if (key.startsWith('hoverOutline')) {\n      targetKey = `hover${key.slice('hoverOutline'.length)}`;\n    } else {\n      return;\n    }\n    delete r[key];\n    r[targetKey] = options[key];\n  });\n  return r;\n}\nclass GeoController extends DatasetController {\n  getGeoDataset() {\n    return super.getDataset();\n  }\n  getGeoOptions() {\n    return this.chart.options;\n  }\n  getProjectionScale() {\n    return this.getScaleForId('projection');\n  }\n  linkScales() {\n    const dataset = this.getGeoDataset();\n    const meta = this.getMeta();\n    meta.xAxisID = 'projection';\n    dataset.xAxisID = 'projection';\n    meta.yAxisID = 'projection';\n    dataset.yAxisID = 'projection';\n    meta.xScale = this.getScaleForId('projection');\n    meta.yScale = this.getScaleForId('projection');\n    this.getProjectionScale().computeBounds(this.resolveOutline());\n  }\n  showOutline() {\n    return valueOrDefault(this.getGeoDataset().showOutline, this.getGeoOptions().showOutline);\n  }\n  clipMap() {\n    return valueOrDefault(this.getGeoDataset().clipMap, this.getGeoOptions().clipMap);\n  }\n  getGraticule() {\n    return valueOrDefault(this.getGeoDataset().showGraticule, this.getGeoOptions().showGraticule);\n  }\n  update(mode) {\n    super.update(mode);\n    const meta = this.getMeta();\n    const scale = this.getProjectionScale();\n    const dirtyCache = scale.updateBounds();\n    if (this.showOutline()) {\n      const elem = meta.dataset;\n      if (dirtyCache) {\n        delete elem.cache;\n      }\n      elem.projectionScale = scale;\n      elem.pixelRatio = this.chart.currentDevicePixelRatio;\n      if (mode !== 'resize') {\n        const options = patchDatasetElementOptions(this.resolveDatasetElementOptions(mode));\n        const properties = {\n          feature: this.resolveOutline(),\n          options\n        };\n        this.updateElement(elem, undefined, properties, mode);\n        if (this.getGraticule()) {\n          meta.graticule = options;\n        }\n      }\n    } else if (this.getGraticule() && mode !== 'resize') {\n      meta.graticule = patchDatasetElementOptions(this.resolveDatasetElementOptions(mode));\n    }\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n    if (dirtyCache) {\n      meta.data.forEach(elem => delete elem.cache);\n    }\n  }\n  resolveOutline() {\n    const ds = this.getGeoDataset();\n    const outline = ds.outline || {\n      type: 'Sphere'\n    };\n    if (Array.isArray(outline)) {\n      return {\n        type: 'FeatureCollection',\n        features: outline\n      };\n    }\n    return outline;\n  }\n  showGraticule() {\n    const g = this.getGraticule();\n    const options = this.getMeta().graticule;\n    if (!g || !options) {\n      return;\n    }\n    const {\n      ctx\n    } = this.chart;\n    const scale = this.getProjectionScale();\n    const path = scale.geoPath.context(ctx);\n    ctx.save();\n    ctx.beginPath();\n    if (typeof g === 'boolean') {\n      if (g) {\n        path(geoGraticule10());\n      }\n    } else {\n      const geo = geoGraticule();\n      if (g.stepMajor) {\n        geo.stepMajor(g.stepMajor);\n      }\n      if (g.stepMinor) {\n        geo.stepMinor(g.stepMinor);\n      }\n      path(geo());\n    }\n    ctx.strokeStyle = options.graticuleBorderColor;\n    ctx.lineWidth = options.graticuleBorderWidth;\n    ctx.stroke();\n    ctx.restore();\n  }\n  draw() {\n    const {\n      chart\n    } = this;\n    const clipMap = this.clipMap();\n    let enabled = false;\n    if (clipMap === true || clipMap === 'outline' || clipMap === 'outline+graticule') {\n      enabled = true;\n      clipArea(chart.ctx, chart.chartArea);\n    }\n    if (this.showOutline() && this.getMeta().dataset) {\n      this.getMeta().dataset.draw.call(this.getMeta().dataset, chart.ctx, chart.chartArea);\n    }\n    if (clipMap === true || clipMap === 'graticule' || clipMap === 'outline+graticule') {\n      if (!enabled) {\n        clipArea(chart.ctx, chart.chartArea);\n      }\n    } else if (enabled) {\n      enabled = false;\n      unclipArea(chart.ctx);\n    }\n    this.showGraticule();\n    if (clipMap === true || clipMap === 'items') {\n      if (!enabled) {\n        clipArea(chart.ctx, chart.chartArea);\n      }\n    } else if (enabled) {\n      enabled = false;\n      unclipArea(chart.ctx);\n    }\n    this.getMeta().data.forEach(elem => elem.draw.call(elem, chart.ctx, chart.chartArea));\n    if (enabled) {\n      enabled = false;\n      unclipArea(chart.ctx);\n    }\n  }\n}\nfunction patchController(type, config, controller, elements = [], scales = []) {\n  registry.addControllers(controller);\n  if (Array.isArray(elements)) {\n    registry.addElements(...elements);\n  } else {\n    registry.addElements(elements);\n  }\n  if (Array.isArray(scales)) {\n    registry.addScales(...scales);\n  } else {\n    registry.addScales(scales);\n  }\n  const c = config;\n  c.type = type;\n  return c;\n}\nclass ChoroplethController extends GeoController {\n  initialize() {\n    super.initialize();\n    this.enableOptionSharing = true;\n  }\n  linkScales() {\n    super.linkScales();\n    const dataset = this.getGeoDataset();\n    const meta = this.getMeta();\n    meta.vAxisID = 'color';\n    meta.rAxisID = 'color';\n    dataset.vAxisID = 'color';\n    dataset.rAxisID = 'color';\n    meta.rScale = this.getScaleForId('color');\n    meta.vScale = meta.rScale;\n    meta.iScale = meta.xScale;\n    meta.iAxisID = meta.xAxisID;\n    dataset.iAxisID = meta.xAxisID;\n  }\n  _getOtherScale(scale) {\n    return scale;\n  }\n  parse(start, count) {\n    const rScale = this.getMeta().rScale;\n    const {\n      data\n    } = this.getDataset();\n    const meta = this._cachedMeta;\n    for (let i = start; i < start + count; i += 1) {\n      meta._parsed[i] = {\n        [rScale.axis]: rScale.parse(data[i], i)\n      };\n    }\n  }\n  updateElements(elems, start, count, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const scale = this.getProjectionScale();\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    for (let i = start; i < start + count; i += 1) {\n      const elem = elems[i];\n      elem.projectionScale = scale;\n      elem.feature = this._data[i].feature;\n      elem.center = this._data[i].center;\n      elem.pixelRatio = this.chart.currentDevicePixelRatio;\n      const center = elem.getCenterPoint();\n      const properties = {\n        x: center.x,\n        y: center.y\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, mode);\n      }\n      this.updateElement(elem, i, properties, mode);\n    }\n  }\n  indexToColor(index) {\n    const rScale = this.getMeta().rScale;\n    return rScale.getColorForValue(this.getParsed(index)[rScale.axis]);\n  }\n}\nChoroplethController.id = 'choropleth';\nChoroplethController.defaults = merge({}, [geoDefaults, {\n  datasetElementType: GeoFeature.id,\n  dataElementType: GeoFeature.id\n}]);\nChoroplethController.overrides = merge({}, [geoOverrides, {\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(item) {\n          var _a, _b, _c, _d;\n          if (item.formattedValue == null) {\n            return (_b = (_a = item.chart.data) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b[item.dataIndex];\n          }\n          return `${(_d = (_c = item.chart.data) === null || _c === void 0 ? void 0 : _c.labels) === null || _d === void 0 ? void 0 : _d[item.dataIndex]}: ${item.formattedValue}`;\n        }\n      }\n    },\n    colors: {\n      enabled: false\n    }\n  },\n  scales: {\n    color: {\n      type: ColorScale.id,\n      axis: 'x'\n    }\n  },\n  elements: {\n    geoFeature: {\n      backgroundColor(context) {\n        if (context.dataIndex == null) {\n          return null;\n        }\n        const controller = context.chart.getDatasetMeta(context.datasetIndex).controller;\n        return controller.indexToColor(context.dataIndex);\n      }\n    }\n  }\n}]);\nclass ChoroplethChart extends Chart {\n  constructor(item, config) {\n    super(item, patchController('choropleth', config, ChoroplethController, GeoFeature, [ColorScale, ProjectionScale]));\n  }\n}\nChoroplethChart.id = ChoroplethController.id;\nclass BubbleMapController extends GeoController {\n  initialize() {\n    super.initialize();\n    this.enableOptionSharing = true;\n  }\n  linkScales() {\n    super.linkScales();\n    const dataset = this.getGeoDataset();\n    const meta = this.getMeta();\n    meta.vAxisID = 'size';\n    meta.rAxisID = 'size';\n    dataset.vAxisID = 'size';\n    dataset.rAxisID = 'size';\n    meta.rScale = this.getScaleForId('size');\n    meta.vScale = meta.rScale;\n    meta.iScale = meta.xScale;\n    meta.iAxisID = meta.xAxisID;\n    dataset.iAxisID = meta.xAxisID;\n  }\n  _getOtherScale(scale) {\n    return scale;\n  }\n  parse(start, count) {\n    const rScale = this.getMeta().rScale;\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n    for (let i = start; i < start + count; i += 1) {\n      const d = data[i];\n      meta._parsed[i] = {\n        x: d.longitude == null ? d.x : d.longitude,\n        y: d.latitude == null ? d.y : d.latitude,\n        [rScale.axis]: rScale.parse(d, i)\n      };\n    }\n  }\n  updateElements(elems, start, count, mode) {\n    const reset = mode === 'reset';\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const scale = this.getProjectionScale();\n    this.getMeta().rScale._model = firstOpts;\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    for (let i = start; i < start + count; i += 1) {\n      const elem = elems[i];\n      const parsed = this.getParsed(i);\n      const projection = scale.projection([parsed.x, parsed.y]);\n      const properties = {\n        x: projection ? projection[0] : 0,\n        y: projection ? projection[1] : 0,\n        skip: Number.isNaN(parsed.x) || Number.isNaN(parsed.y)\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, mode);\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n      this.updateElement(elem, i, properties, mode);\n    }\n  }\n  indexToRadius(index) {\n    const rScale = this.getMeta().rScale;\n    return rScale.getSizeForValue(this.getParsed(index)[rScale.axis]);\n  }\n}\nBubbleMapController.id = 'bubbleMap';\nBubbleMapController.defaults = merge({}, [geoDefaults, {\n  dataElementType: PointElement.id,\n  datasetElementType: GeoFeature.id,\n  showOutline: true,\n  clipMap: 'outline+graticule'\n}]);\nBubbleMapController.overrides = merge({}, [geoOverrides, {\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(item) {\n          var _a, _b, _c, _d;\n          if (item.formattedValue == null) {\n            return (_b = (_a = item.chart.data) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b[item.dataIndex];\n          }\n          return `${(_d = (_c = item.chart.data) === null || _c === void 0 ? void 0 : _c.labels) === null || _d === void 0 ? void 0 : _d[item.dataIndex]}: ${item.formattedValue}`;\n        }\n      }\n    }\n  },\n  scales: {\n    size: {\n      axis: 'x',\n      type: SizeScale.id\n    }\n  },\n  elements: {\n    point: {\n      radius(context) {\n        if (context.dataIndex == null) {\n          return null;\n        }\n        const controller = context.chart.getDatasetMeta(context.datasetIndex).controller;\n        return controller.indexToRadius(context.dataIndex);\n      },\n      hoverRadius(context) {\n        if (context.dataIndex == null) {\n          return null;\n        }\n        const controller = context.chart.getDatasetMeta(context.datasetIndex).controller;\n        return controller.indexToRadius(context.dataIndex) + 1;\n      }\n    }\n  }\n}]);\nclass BubbleMapChart extends Chart {\n  constructor(item, config) {\n    super(item, patchController('bubbleMap', config, BubbleMapController, GeoFeature, [SizeScale, ProjectionScale]));\n  }\n}\nBubbleMapChart.id = BubbleMapController.id;\nexport { BubbleMapChart, BubbleMapController, ChoroplethChart, ChoroplethController, ColorLogarithmicScale, ColorScale, GeoController, GeoFeature, ProjectionScale, SizeLogarithmicScale, SizeScale };","map":{"version":3,"names":["lookup$1","geoAzimuthalEqualArea","geoAzimuthalEquidistant","geoGnomonic","geoOrthographic","geoStereographic","geoEqualEarth","geoAlbers","geoAlbersUsa","geoConicConformal","geoConicEqualArea","geoConicEquidistant","geoEquirectangular","geoMercator","geoTransverseMercator","geoNaturalEarth1","Object","keys","forEach","key","charAt","toLowerCase","slice","ProjectionScale","Scale","constructor","cfg","outlineBounds","oldChartBounds","geoPath","init","options","position","projection","albersUsa","computeBounds","outline","bb","fitWidth","bounds","bHeight","Math","ceil","bWidth","t","translate","width","height","aspectRatio","refScale","scale","refX","refY","updateBounds","area","chart","chartArea","padding","paddingTop","top","paddingLeft","left","paddingBottom","bottom","paddingRight","right","chartWidth","chartHeight","bak","min","viewWidth","viewHeight","x","y","o","projectionScale","projectionOffset","id","defaults","descriptors","_scriptable","name","_indexable","baseDefaults","property","grid","z","drawOnChartArea","ticks","legend","align","length","margin","indicatorWidth","computeLegendMargin","pos","computeLegendPosition","legendSize","axisPos","isHor","w","h","LegendScale","LinearScale","axis","parse","raw","index","isHorizontal","_getNormalizedValue","v","Number","isNaN","_startValue","_valueRange","update","maxWidth","maxHeight","margins","ch","POSITIVE_INFINITY","cw","l","factor","full","r","_computeLabelArea","undefined","draw","_isVisible","ctx","save","_drawIndicator","restore","LogarithmicLegendScale","LogarithmicScale","prototype","call","log10","lookup","interpolateBlues","interpolateBrBG","interpolateBuGn","interpolateBuPu","interpolateCividis","interpolateCool","interpolateCubehelixDefault","interpolateGnBu","interpolateGreens","interpolateGreys","interpolateInferno","interpolateMagma","interpolateOrRd","interpolateOranges","interpolatePRGn","interpolatePiYG","interpolatePlasma","interpolatePuBu","interpolatePuBuGn","interpolatePuOr","interpolatePuRd","interpolatePurples","interpolateRainbow","interpolateRdBu","interpolateRdGy","interpolateRdPu","interpolateRdYlBu","interpolateRdYlGn","interpolateReds","interpolateSinebow","interpolateSpectral","interpolateTurbo","interpolateViridis","interpolateWarm","interpolateYlGn","interpolateYlGnBu","interpolateYlOrBr","interpolateYlOrRd","quantize","steps","perStep","acc","colorScaleDefaults","interpolate","missing","ColorScale","blues","getColorForValue","value","getColor","normalized","indicatorSize","reverse","_reversePixels","stepWidth","offset","i","fillStyle","fillRect","merge","ColorLogarithmicScale","scaleDefaults","mode","range","SizeScale","_model","getSizeForValue","getSizeImpl","r0","r1","a1","PI","a0","a","sqrt","shift","values","labelItems","getLabelItems","positions","map","el","translation","_","getPixelForTick","_gridLineItems","item","strokeStyle","color","lineWidth","setLineDash","borderDash","lineDashOffset","borderDashOffset","beginPath","drawTicks","moveTo","ty1","lineTo","ty2","tx1","tx2","stroke","props","borderColor","borderWidth","backgroundColor","radius","renderOptions","pointStyle","drawPoint","SizeLogarithmicScale","growGeoBounds","amount","GeoFeature","Element","cache","inRange","mouseX","mouseY","getBounds","x2","y2","invert","longLat","geoContains","feature","inXRange","NaN","inYRange","getCenterPoint","center","p","longitude","latitude","centroid","_drawInCache","doc","isFinite","canvas","createElement","x1","floor","y1","pixelRatio","max","getContext","clearRect","_drawImpl","canvasKey","_optionsToKey","context","fill","ownerDocument","drawImage","BarElement","outlineBackgroundColor","outlineBorderWidth","graticuleBorderColor","graticuleBorderWidth","defaultRoutes","outlineBorderColor","geoDefaults","showOutline","showGraticule","clipMap","geoOverrides","scales","type","display","patchDatasetElementOptions","targetKey","startsWith","sub","GeoController","DatasetController","getGeoDataset","getDataset","getGeoOptions","getProjectionScale","getScaleForId","linkScales","dataset","meta","getMeta","xAxisID","yAxisID","xScale","yScale","resolveOutline","valueOrDefault","getGraticule","dirtyCache","elem","currentDevicePixelRatio","resolveDatasetElementOptions","properties","updateElement","graticule","updateElements","data","ds","Array","isArray","features","g","path","geoGraticule10","geo","geoGraticule","stepMajor","stepMinor","enabled","clipArea","unclipArea","patchController","config","controller","elements","registry","addControllers","addElements","addScales","c","ChoroplethController","initialize","enableOptionSharing","vAxisID","rAxisID","rScale","vScale","iScale","iAxisID","_getOtherScale","start","count","_cachedMeta","_parsed","elems","firstOpts","resolveDataElementOptions","sharedOptions","getSharedOptions","includeOptions","updateSharedOptions","_data","indexToColor","getParsed","datasetElementType","dataElementType","overrides","plugins","tooltip","callbacks","title","label","formattedValue","_b","_a","labels","dataIndex","_d","_c","colors","geoFeature","getDatasetMeta","datasetIndex","ChoroplethChart","Chart","BubbleMapController","d","reset","parsed","skip","indexToRadius","PointElement","size","point","hoverRadius","BubbleMapChart"],"sources":["/Users/kylecoon/Desktop/HowsTheMarket/node_modules/chartjs-chart-geo/src/scales/ProjectionScale.ts","/Users/kylecoon/Desktop/HowsTheMarket/node_modules/chartjs-chart-geo/src/scales/LegendScale.ts","/Users/kylecoon/Desktop/HowsTheMarket/node_modules/chartjs-chart-geo/src/scales/ColorScale.ts","/Users/kylecoon/Desktop/HowsTheMarket/node_modules/chartjs-chart-geo/src/scales/SizeScale.ts","/Users/kylecoon/Desktop/HowsTheMarket/node_modules/chartjs-chart-geo/src/elements/GeoFeature.ts","/Users/kylecoon/Desktop/HowsTheMarket/node_modules/chartjs-chart-geo/src/controllers/GeoController.ts","/Users/kylecoon/Desktop/HowsTheMarket/node_modules/chartjs-chart-geo/src/controllers/patchController.ts","/Users/kylecoon/Desktop/HowsTheMarket/node_modules/chartjs-chart-geo/src/controllers/ChoroplethController.ts","/Users/kylecoon/Desktop/HowsTheMarket/node_modules/chartjs-chart-geo/src/controllers/BubbleMapController.ts"],"sourcesContent":["import { Scale, CoreScaleOptions } from 'chart.js';\nimport {\n  geoPath,\n  geoAzimuthalEqualArea,\n  geoAzimuthalEquidistant,\n  geoGnomonic,\n  geoOrthographic,\n  geoStereographic,\n  geoEqualEarth,\n  geoAlbers,\n  geoAlbersUsa,\n  geoConicConformal,\n  geoConicEqualArea,\n  geoConicEquidistant,\n  geoEquirectangular,\n  geoMercator,\n  geoTransverseMercator,\n  geoNaturalEarth1,\n  GeoProjection,\n  GeoPath,\n  GeoPermissibleObjects,\n  ExtendedFeatureCollection,\n  ExtendedFeature,\n  GeoGeometryObjects,\n  ExtendedGeometryCollection,\n} from 'd3-geo';\n\nconst lookup: { [key: string]: () => GeoProjection } = {\n  geoAzimuthalEqualArea,\n  geoAzimuthalEquidistant,\n  geoGnomonic,\n  geoOrthographic,\n  geoStereographic,\n  geoEqualEarth,\n  geoAlbers,\n  geoAlbersUsa,\n  geoConicConformal,\n  geoConicEqualArea,\n  geoConicEquidistant,\n  geoEquirectangular,\n  geoMercator,\n  geoTransverseMercator,\n  geoNaturalEarth1,\n};\nObject.keys(lookup).forEach((key) => {\n  lookup[`${key.charAt(3).toLowerCase()}${key.slice(4)}`] = lookup[key];\n});\n\nexport interface IProjectionScaleOptions extends CoreScaleOptions {\n  /**\n   * projection method used\n   * @default albersUsa\n   */\n  projection:\n    | GeoProjection\n    | 'azimuthalEqualArea'\n    | 'azimuthalEquidistant'\n    | 'gnomonic'\n    | 'orthographic'\n    | 'stereographic'\n    | 'equalEarth'\n    | 'albers'\n    | 'albersUsa'\n    | 'conicConformal'\n    | 'conicEqualArea'\n    | 'conicEquidistant'\n    | 'equirectangular'\n    | 'mercator'\n    | 'transverseMercator'\n    | 'naturalEarth1';\n\n  /**\n   * extra scale factor applied to projection\n   */\n  projectionScale: number;\n  /**\n   * extra offset applied after projection\n   */\n  projectionOffset: [number, number];\n  /**\n   * padding applied during auto scaling of the map in pixels\n   * i.e. the chart size is reduce by the padding before fitting the map\n   */\n  padding: number | { top: number; left: number; right: number; bottom: number };\n}\n\nexport class ProjectionScale extends Scale<IProjectionScaleOptions> {\n  /**\n   * @hidden\n   */\n  readonly geoPath: GeoPath<any, GeoPermissibleObjects>;\n\n  /**\n   * @hidden\n   */\n  projection!: GeoProjection;\n\n  private outlineBounds: {\n    refX: number;\n    refY: number;\n    refScale: number;\n    width: number;\n    height: number;\n    aspectRatio: number;\n  } | null = null;\n\n  private oldChartBounds: { chartWidth: number; chartHeight: number } | null = null;\n\n  constructor(cfg: any) {\n    super(cfg);\n    this.geoPath = geoPath();\n  }\n\n  /**\n   * @hidden\n   */\n  init(options: IProjectionScaleOptions): void {\n    (options as any).position = 'chartArea';\n    super.init(options);\n    if (typeof options.projection === 'function') {\n      this.projection = options.projection;\n    } else {\n      this.projection = (lookup[options.projection] || lookup.albersUsa)();\n    }\n    this.geoPath.projection(this.projection);\n\n    this.outlineBounds = null;\n    this.oldChartBounds = null;\n  }\n\n  /**\n   * @hidden\n   */\n  computeBounds(outline: ExtendedFeature): void;\n  computeBounds(outline: ExtendedFeatureCollection): void;\n  computeBounds(outline: GeoGeometryObjects): void;\n  computeBounds(outline: ExtendedGeometryCollection): void;\n\n  computeBounds(outline: any): void {\n    const bb = geoPath(this.projection.fitWidth(1000, outline)).bounds(outline);\n    const bHeight = Math.ceil(bb[1][1] - bb[0][1]);\n    const bWidth = Math.ceil(bb[1][0] - bb[0][0]);\n    const t = this.projection.translate();\n\n    this.outlineBounds = {\n      width: bWidth,\n      height: bHeight,\n      aspectRatio: bWidth / bHeight,\n      refScale: this.projection.scale(),\n      refX: t[0],\n      refY: t[1],\n    };\n  }\n\n  /**\n   * @hidden\n   */\n  updateBounds(): boolean {\n    const area = this.chart.chartArea;\n\n    const bb = this.outlineBounds;\n\n    if (!bb) {\n      return false;\n    }\n    const padding = this.options.padding;\n    const paddingTop = typeof padding === 'number' ? padding : padding.top;\n    const paddingLeft = typeof padding === 'number' ? padding : padding.left;\n    const paddingBottom = typeof padding === 'number' ? padding : padding.bottom;\n    const paddingRight = typeof padding === 'number' ? padding : padding.right;\n\n    const chartWidth = area.right - area.left - paddingLeft - paddingRight;\n    const chartHeight = area.bottom - area.top - paddingTop - paddingBottom;\n\n    const bak = this.oldChartBounds;\n    this.oldChartBounds = {\n      chartWidth,\n      chartHeight,\n    };\n\n    const scale = Math.min(chartWidth / bb.width, chartHeight / bb.height);\n    const viewWidth = bb.width * scale;\n    const viewHeight = bb.height * scale;\n\n    const x = (chartWidth - viewWidth) * 0.5 + area.left + paddingLeft;\n    const y = (chartHeight - viewHeight) * 0.5 + area.top + paddingTop;\n\n    // this.mapScale = scale;\n    // this.mapTranslate = {x, y};\n\n    const o = this.options;\n\n    this.projection\n      .scale(bb.refScale * scale * o.projectionScale)\n      .translate([scale * bb.refX + x + o.projectionOffset[0], scale * bb.refY + y + o.projectionOffset[1]]);\n\n    return (\n      !bak || bak.chartWidth !== this.oldChartBounds.chartWidth || bak.chartHeight !== this.oldChartBounds.chartHeight\n    );\n  }\n\n  static readonly id = 'projection';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: Partial<IProjectionScaleOptions> = {\n    projection: 'albersUsa',\n    projectionScale: 1,\n    projectionOffset: [0, 0],\n    padding: 0,\n  };\n\n  /**\n   * @hidden\n   */\n  static readonly descriptors = /* #__PURE__ */ {\n    _scriptable: (name: keyof IProjectionScaleOptions): boolean => name !== 'projection',\n    _indexable: (name: keyof IProjectionScaleOptions): boolean => name !== 'projectionOffset',\n  };\n}\n\ndeclare module 'chart.js' {\n  export interface ProjectionScaleTypeRegistry {\n    projection: {\n      options: IProjectionScaleOptions;\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  export interface ScaleTypeRegistry extends ProjectionScaleTypeRegistry {}\n}\n","import {\n  ChartArea,\n  CartesianScaleOptions,\n  LinearScale,\n  LinearScaleOptions,\n  LogarithmicScale,\n  LogarithmicScaleOptions,\n} from 'chart.js';\n\nexport interface ILegendScaleOptions extends CartesianScaleOptions {\n  /**\n   * whether to render a color legend\n   * @default true\n   */\n  display: boolean;\n\n  /**\n   * the property name that stores the value in the data elements\n   * @default value\n   */\n  property: string;\n\n  legend: {\n    /**\n     * location of the legend on the chart area\n     * @default bottom-right\n     */\n    position:\n      | 'left'\n      | 'right'\n      | 'top'\n      | 'bottom'\n      | 'top-left'\n      | 'top-right'\n      | 'top-right'\n      | 'bottom-right'\n      | 'bottom-left'\n      | { x: number; y: number };\n    /**\n     * alignment of the scale, e.g., `right` means that it is a vertical scale\n     * with the ticks on the right side\n     * @default right\n     */\n    align: 'left' | 'right' | 'top' | 'bottom';\n    /**\n     * length of the legend, i.e., for a horizontal scale the width\n     * if a value < 1 is given, is it assume to be a ratio of the corresponding\n     * chart area\n     * @default 100\n     */\n    length: number;\n    /**\n     * how wide the scale is, i.e., for a horizontal scale the height\n     * if a value < 1 is given, is it assume to be a ratio of the corresponding\n     * chart area\n     * @default 50\n     */\n    width: number;\n    /**\n     * how many pixels should be used for the color bar\n     * @default 10\n     */\n    indicatorWidth: number;\n    /**\n     * margin pixels such that it doesn't stick to the edge of the chart\n     * @default 8\n     */\n    margin: number | ChartArea;\n  };\n}\n\nexport const baseDefaults = {\n  position: 'chartArea',\n  property: 'value',\n  grid: {\n    z: 1,\n    drawOnChartArea: false,\n  },\n  ticks: {\n    z: 1,\n  },\n  legend: {\n    align: 'right',\n    position: 'bottom-right',\n    length: 100,\n    width: 50,\n    margin: 8,\n    indicatorWidth: 10,\n  },\n};\n\ninterface IPositionOption {\n  position?: string;\n}\n\nfunction computeLegendMargin(legend: ILegendScaleOptions['legend']): {\n  left: number;\n  top: number;\n  right: number;\n  bottom: number;\n} {\n  const { indicatorWidth, align: pos, margin } = legend;\n\n  const left = (typeof margin === 'number' ? margin : margin.left) + (pos === 'right' ? indicatorWidth : 0);\n  const top = (typeof margin === 'number' ? margin : margin.top) + (pos === 'bottom' ? indicatorWidth : 0);\n  const right = (typeof margin === 'number' ? margin : margin.right) + (pos === 'left' ? indicatorWidth : 0);\n  const bottom = (typeof margin === 'number' ? margin : margin.bottom) + (pos === 'top' ? indicatorWidth : 0);\n  return { left, top, right, bottom };\n}\n\nfunction computeLegendPosition(\n  chartArea: ChartArea,\n  legend: ILegendScaleOptions['legend'],\n  width: number,\n  height: number,\n  legendSize: { w: number; h: number }\n): [number, number] {\n  const { indicatorWidth, align: axisPos, position: pos } = legend;\n  const isHor = axisPos === 'top' || axisPos === 'bottom';\n  const w = (axisPos === 'left' ? legendSize.w : width) + (isHor ? indicatorWidth : 0);\n  const h = (axisPos === 'top' ? legendSize.h : height) + (!isHor ? indicatorWidth : 0);\n  const margin = computeLegendMargin(legend);\n\n  if (typeof pos === 'string') {\n    switch (pos) {\n      case 'top-left':\n        return [margin.left, margin.top];\n      case 'top':\n        return [(chartArea.right - w) / 2, margin.top];\n      case 'left':\n        return [margin.left, (chartArea.bottom - h) / 2];\n      case 'top-right':\n        return [chartArea.right - w - margin.right, margin.top];\n      case 'bottom-right':\n        return [chartArea.right - w - margin.right, chartArea.bottom - h - margin.bottom];\n      case 'bottom':\n        return [(chartArea.right - w) / 2, chartArea.bottom - h - margin.bottom];\n      case 'bottom-left':\n        return [margin.left, chartArea.bottom - h - margin.bottom];\n      default:\n        // right\n        return [chartArea.right - w - margin.right, (chartArea.bottom - h) / 2];\n    }\n  }\n  return [pos.x, pos.y];\n}\n\nexport class LegendScale<O extends ILegendScaleOptions & LinearScaleOptions> extends LinearScale<O> {\n  /**\n   * @hidden\n   */\n  legendSize: { w: number; h: number } = { w: 0, h: 0 };\n\n  /**\n   * @hidden\n   */\n  init(options: O): void {\n    (options as unknown as IPositionOption).position = 'chartArea';\n    super.init(options);\n    this.axis = 'r';\n  }\n\n  /**\n   * @hidden\n   */\n\n  parse(raw: any, index: number): number {\n    if (raw && typeof raw[this.options.property] === 'number') {\n      return raw[this.options.property];\n    }\n    return super.parse(raw, index) as number;\n  }\n\n  /**\n   * @hidden\n   */\n  isHorizontal(): boolean {\n    return this.options.legend.align === 'top' || this.options.legend.align === 'bottom';\n  }\n\n  protected _getNormalizedValue(v: number): number | null {\n    if (v == null || Number.isNaN(v)) {\n      return null;\n    }\n    return (v - (this as any)._startValue) / (this as any)._valueRange;\n  }\n\n  /**\n   * @hidden\n   */\n  update(maxWidth: number, maxHeight: number, margins: ChartArea): void {\n    const ch = Math.min(maxHeight, this.bottom == null ? Number.POSITIVE_INFINITY : this.bottom);\n    const cw = Math.min(maxWidth, this.right == null ? Number.POSITIVE_INFINITY : this.right);\n\n    const l = this.options.legend;\n    const isHor = this.isHorizontal();\n    const factor = (v: number, full: number) => (v < 1 ? full * v : v);\n    const w = Math.min(cw, factor(isHor ? l.length : l.width, cw)) - (!isHor ? l.indicatorWidth : 0);\n    const h = Math.min(ch, factor(!isHor ? l.length : l.width, ch)) - (isHor ? l.indicatorWidth : 0);\n    this.legendSize = { w, h };\n    this.bottom = h;\n    this.height = h;\n    this.right = w;\n    this.width = w;\n\n    const bak = (this.options as IPositionOption).position;\n    (this.options as IPositionOption).position = this.options.legend.align;\n    const r = super.update(w, h, margins);\n    (this.options as IPositionOption).position = bak;\n    this.height = Math.min(h, this.height);\n    this.width = Math.min(w, this.width);\n    return r;\n  }\n\n  /**\n   * @hidden\n   */\n\n  _computeLabelArea(): void {\n    return undefined;\n  }\n\n  /**\n   * @hidden\n   */\n  draw(chartArea: ChartArea): void {\n    if (!(this as any)._isVisible()) {\n      return;\n    }\n    const pos = computeLegendPosition(chartArea, this.options.legend, this.width, this.height, this.legendSize);\n    /** @type {CanvasRenderingContext2D} */\n    const { ctx } = this;\n    ctx.save();\n    ctx.translate(pos[0], pos[1]);\n\n    const bak = (this.options as IPositionOption).position;\n    (this.options as IPositionOption).position = this.options.legend.align;\n    super.draw({ ...chartArea, bottom: this.height + 10, right: this.width });\n    (this.options as IPositionOption).position = bak;\n    const { indicatorWidth } = this.options.legend;\n    switch (this.options.legend.align) {\n      case 'left':\n        ctx.translate(this.legendSize.w, 0);\n        break;\n      case 'top':\n        ctx.translate(0, this.legendSize.h);\n        break;\n      case 'bottom':\n        ctx.translate(0, -indicatorWidth);\n        break;\n      default:\n        ctx.translate(-indicatorWidth, 0);\n        break;\n    }\n    this._drawIndicator();\n    ctx.restore();\n  }\n\n  /**\n   * @hidden\n   */\n\n  protected _drawIndicator(): void {\n    // hook\n  }\n}\n\nexport class LogarithmicLegendScale<\n  O extends ILegendScaleOptions & LogarithmicScaleOptions,\n> extends LogarithmicScale<O> {\n  /**\n   * @hidden\n   */\n  legendSize: { w: number; h: number } = { w: 0, h: 0 };\n\n  /**\n   * @hidden\n   */\n  init(options: O): void {\n    LegendScale.prototype.init.call(this, options);\n  }\n\n  /**\n   * @hidden\n   */\n\n  parse(raw: any, index: number): number {\n    return LegendScale.prototype.parse.call(this, raw, index);\n  }\n\n  /**\n   * @hidden\n   */\n  isHorizontal(): boolean {\n    return this.options.legend.align === 'top' || this.options.legend.align === 'bottom';\n  }\n\n  protected _getNormalizedValue(v: number): number | null {\n    if (v == null || Number.isNaN(v)) {\n      return null;\n    }\n    return (Math.log10(v) - (this as any)._startValue) / (this as any)._valueRange;\n  }\n\n  /**\n   * @hidden\n   */\n  update(maxWidth: number, maxHeight: number, margins: ChartArea): void {\n    return LegendScale.prototype.update.call(this, maxWidth, maxHeight, margins);\n  }\n\n  /**\n   * @hidden\n   */\n\n  _computeLabelArea(): void {\n    return undefined;\n  }\n\n  /**\n   * @hidden\n   */\n  draw(chartArea: ChartArea): void {\n    return LegendScale.prototype.draw.call(this, chartArea);\n  }\n\n  protected _drawIndicator(): void {\n    // hook\n  }\n}\n","import { LinearScale, LogarithmicScale, LogarithmicScaleOptions, LinearScaleOptions } from 'chart.js';\nimport { merge } from 'chart.js/helpers';\nimport {\n  interpolateBlues,\n  interpolateBrBG,\n  interpolateBuGn,\n  interpolateBuPu,\n  interpolateCividis,\n  interpolateCool,\n  interpolateCubehelixDefault,\n  interpolateGnBu,\n  interpolateGreens,\n  interpolateGreys,\n  interpolateInferno,\n  interpolateMagma,\n  interpolateOrRd,\n  interpolateOranges,\n  interpolatePRGn,\n  interpolatePiYG,\n  interpolatePlasma,\n  interpolatePuBu,\n  interpolatePuBuGn,\n  interpolatePuOr,\n  interpolatePuRd,\n  interpolatePurples,\n  interpolateRainbow,\n  interpolateRdBu,\n  interpolateRdGy,\n  interpolateRdPu,\n  interpolateRdYlBu,\n  interpolateRdYlGn,\n  interpolateReds,\n  interpolateSinebow,\n  interpolateSpectral,\n  interpolateTurbo,\n  interpolateViridis,\n  interpolateWarm,\n  interpolateYlGn,\n  interpolateYlGnBu,\n  interpolateYlOrBr,\n  interpolateYlOrRd,\n} from 'd3-scale-chromatic';\nimport { baseDefaults, LegendScale, LogarithmicLegendScale, ILegendScaleOptions } from './LegendScale';\n\nconst lookup: { [key: string]: (normalizedValue: number) => string } = {\n  interpolateBlues,\n  interpolateBrBG,\n  interpolateBuGn,\n  interpolateBuPu,\n  interpolateCividis,\n  interpolateCool,\n  interpolateCubehelixDefault,\n  interpolateGnBu,\n  interpolateGreens,\n  interpolateGreys,\n  interpolateInferno,\n  interpolateMagma,\n  interpolateOrRd,\n  interpolateOranges,\n  interpolatePRGn,\n  interpolatePiYG,\n  interpolatePlasma,\n  interpolatePuBu,\n  interpolatePuBuGn,\n  interpolatePuOr,\n  interpolatePuRd,\n  interpolatePurples,\n  interpolateRainbow,\n  interpolateRdBu,\n  interpolateRdGy,\n  interpolateRdPu,\n  interpolateRdYlBu,\n  interpolateRdYlGn,\n  interpolateReds,\n  interpolateSinebow,\n  interpolateSpectral,\n  interpolateTurbo,\n  interpolateViridis,\n  interpolateWarm,\n  interpolateYlGn,\n  interpolateYlGnBu,\n  interpolateYlOrBr,\n  interpolateYlOrRd,\n};\n\nObject.keys(lookup).forEach((key) => {\n  lookup[`${key.charAt(11).toLowerCase()}${key.slice(12)}`] = lookup[key];\n  lookup[key.slice(11)] = lookup[key];\n});\n\nfunction quantize(v: number, steps: number) {\n  const perStep = 1 / steps;\n  if (v <= perStep) {\n    return 0;\n  }\n  if (v >= 1 - perStep) {\n    return 1;\n  }\n  for (let acc = 0; acc < 1; acc += perStep) {\n    if (v < acc) {\n      return acc - perStep / 2; // center\n    }\n  }\n  return v;\n}\n\nexport interface IColorScaleOptions extends ILegendScaleOptions {\n  // support all options from linear scale -> https://www.chartjs.org/docs/latest/axes/cartesian/linear.html#linear-cartesian-axis\n  // e.g. for tick manipulation, ...\n\n  /**\n   * color interpolation method which is either a function\n   * converting a normalized value to string or a\n   * well defined string of all the interpolation scales\n   * from https://github.com/d3/d3-scale-chromatic.\n   * e.g. interpolateBlues -> blues\n   *\n   * @default blues\n   */\n  interpolate:\n    | ((normalizedValue: number) => string)\n    | 'blues'\n    | 'brBG'\n    | 'buGn'\n    | 'buPu'\n    | 'cividis'\n    | 'cool'\n    | 'cubehelixDefault'\n    | 'gnBu'\n    | 'greens'\n    | 'greys'\n    | 'inferno'\n    | 'magma'\n    | 'orRd'\n    | 'oranges'\n    | 'pRGn'\n    | 'piYG'\n    | 'plasma'\n    | 'puBu'\n    | 'puBuGn'\n    | 'puOr'\n    | 'puRd'\n    | 'purples'\n    | 'rainbow'\n    | 'rdBu'\n    | 'rdGy'\n    | 'rdPu'\n    | 'rdYlBu'\n    | 'rdYlGn'\n    | 'reds'\n    | 'sinebow'\n    | 'spectral'\n    | 'turbo'\n    | 'viridis'\n    | 'warm'\n    | 'ylGn'\n    | 'ylGnBu'\n    | 'ylOrBr'\n    | 'ylOrRd';\n\n  /**\n   * color value to render for missing values\n   * @default transparent\n   */\n  missing: string;\n\n  /**\n   * allows to split the color scale in N quantized equal bins.\n   * @default 0\n   */\n  quantize: number;\n}\n\nconst colorScaleDefaults = {\n  interpolate: 'blues',\n  missing: 'transparent',\n  quantize: 0,\n};\n\nexport class ColorScale extends LegendScale<IColorScaleOptions & LinearScaleOptions> {\n  /**\n   * @hidden\n   */\n  get interpolate(): (v: number) => string {\n    const o = this.options as IColorScaleOptions & LinearScaleOptions;\n    if (!o) {\n      return (v: number) => `rgb(${v},${v},${v})`;\n    }\n    if (typeof o.interpolate === 'function') {\n      return o.interpolate;\n    }\n    return lookup[o.interpolate] || lookup.blues;\n  }\n\n  /**\n   * @hidden\n   */\n  getColorForValue(value: number): string {\n    const v = this._getNormalizedValue(value);\n    if (v == null || Number.isNaN(v)) {\n      return this.options.missing;\n    }\n    return this.getColor(v);\n  }\n\n  /**\n   * @hidden\n   */\n  getColor(normalized: number): string {\n    let v = normalized;\n    if (this.options.quantize > 0) {\n      v = quantize(v, this.options.quantize);\n    }\n    return this.interpolate(v);\n  }\n\n  /**\n   * @hidden\n   */\n  _drawIndicator(): void {\n    const { indicatorWidth: indicatorSize } = this.options.legend;\n    const reverse = (this as any)._reversePixels;\n\n    if (this.isHorizontal()) {\n      const w = this.width;\n      if (this.options.quantize > 0) {\n        const stepWidth = w / this.options.quantize;\n        const offset = !reverse ? (i: number) => i : (i: number) => w - stepWidth - i;\n        for (let i = 0; i < w; i += stepWidth) {\n          const v = (i + stepWidth / 2) / w;\n          this.ctx.fillStyle = this.getColor(v);\n          this.ctx.fillRect(offset(i), 0, stepWidth, indicatorSize);\n        }\n      } else {\n        const offset = !reverse ? (i: number) => i : (i: number) => w - 1 - i;\n        for (let i = 0; i < w; i += 1) {\n          this.ctx.fillStyle = this.getColor((i + 0.5) / w);\n          this.ctx.fillRect(offset(i), 0, 1, indicatorSize);\n        }\n      }\n    } else {\n      const h = this.height;\n      if (this.options.quantize > 0) {\n        const stepWidth = h / this.options.quantize;\n        const offset = !reverse ? (i: number) => i : (i: number) => h - stepWidth - i;\n        for (let i = 0; i < h; i += stepWidth) {\n          const v = (i + stepWidth / 2) / h;\n          this.ctx.fillStyle = this.getColor(v);\n          this.ctx.fillRect(0, offset(i), indicatorSize, stepWidth);\n        }\n      } else {\n        const offset = !reverse ? (i: number) => i : (i: number) => h - 1 - i;\n        for (let i = 0; i < h; i += 1) {\n          this.ctx.fillStyle = this.getColor((i + 0.5) / h);\n          this.ctx.fillRect(0, offset(i), indicatorSize, 1);\n        }\n      }\n    }\n  }\n\n  static readonly id = 'color';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [LinearScale.defaults, baseDefaults, colorScaleDefaults]);\n\n  /**\n   * @hidden\n   */\n  static readonly descriptors = /* #__PURE__ */ {\n    _scriptable: (name: string): boolean => name !== 'interpolate',\n    _indexable: false,\n  };\n}\n\nexport class ColorLogarithmicScale extends LogarithmicLegendScale<IColorScaleOptions & LogarithmicScaleOptions> {\n  private interpolate = (v: number) => `rgb(${v},${v},${v})`;\n\n  /**\n   * @hidden\n   */\n  init(options: IColorScaleOptions & LinearScaleOptions): void {\n    super.init(options);\n    if (typeof options.interpolate === 'function') {\n      this.interpolate = options.interpolate;\n    } else {\n      this.interpolate = lookup[options.interpolate] || lookup.blues;\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  getColorForValue(value: number): string {\n    return ColorScale.prototype.getColorForValue.call(this, value);\n  }\n\n  /**\n   * @hidden\n   */\n  getColor(normalized: number): string {\n    let v = normalized;\n    if (this.options.quantize > 0) {\n      v = quantize(v, this.options.quantize);\n    }\n    return this.interpolate(v);\n  }\n\n  protected _drawIndicator(): void {\n    return ColorScale.prototype._drawIndicator.call(this);\n  }\n\n  static readonly id = 'colorLogarithmic';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [\n    LogarithmicScale.defaults,\n    baseDefaults,\n    colorScaleDefaults,\n  ]);\n\n  /**\n   * @hidden\n   */\n  static readonly descriptors = /* #__PURE__ */ {\n    _scriptable: (name: string): boolean => name !== 'interpolate',\n    _indexable: false,\n  };\n}\n\ndeclare module 'chart.js' {\n  export interface ColorScaleTypeRegistry {\n    color: {\n      options: IColorScaleOptions & LinearScaleOptions;\n    };\n    colorLogarithmic: {\n      options: IColorScaleOptions & LogarithmicScaleOptions;\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  export interface ScaleTypeRegistry extends ColorScaleTypeRegistry {}\n}\n","import { LinearScale, LogarithmicScale, PointOptions, LinearScaleOptions, LogarithmicScaleOptions } from 'chart.js';\nimport { merge, drawPoint } from 'chart.js/helpers';\nimport { baseDefaults, ILegendScaleOptions, LegendScale, LogarithmicLegendScale } from './LegendScale';\n\nexport interface ISizeScaleOptions extends ILegendScaleOptions {\n  // support all options from linear scale -> https://www.chartjs.org/docs/latest/axes/cartesian/linear.html#linear-cartesian-axis\n  // e.g. for tick manipulation, ...\n\n  /**\n   * radius range in pixel, the minimal data value will be mapped to the\n   * first entry,  the maximal one to the second and a linear interpolation\n   * for all values in between.\n   *\n   * @default [2, 20]\n   */\n  range: [number, number];\n\n  /**\n   * operation mode for the scale, area means that the area is linearly increasing whereas radius the radius is.\n   * The area one is the default since it gives a better visual comparison of values\n   * @default area\n   */\n  mode: 'radius' | 'area';\n\n  /**\n   * radius to render for missing values\n   * @default 1\n   */\n  missing: number;\n}\n\nconst scaleDefaults = {\n  missing: 1,\n  mode: 'area', // 'radius'\n  // mode: 'radius',\n  range: [2, 20],\n  legend: {\n    align: 'bottom',\n    length: 90,\n    width: 70,\n    indicatorWidth: 42,\n  },\n};\n\nexport class SizeScale extends LegendScale<ISizeScaleOptions & LinearScaleOptions> {\n  /**\n   * @hidden\n   */\n  _model: PointOptions | null = null;\n\n  /**\n   * @hidden\n   */\n  getSizeForValue(value: number): number {\n    const v = this._getNormalizedValue(value);\n    if (v == null || Number.isNaN(v)) {\n      return this.options.missing;\n    }\n    return this.getSizeImpl(v);\n  }\n\n  /**\n   * @hidden\n   */\n  getSizeImpl(normalized: number): number {\n    const [r0, r1] = this.options.range;\n    if (this.options.mode === 'area') {\n      const a1 = r1 * r1 * Math.PI;\n      const a0 = r0 * r0 * Math.PI;\n      const range = a1 - a0;\n      const a = normalized * range + a0;\n      return Math.sqrt(a / Math.PI);\n    }\n    const range = r1 - r0;\n    return normalized * range + r0;\n  }\n\n  /**\n   * @hidden\n   */\n  _drawIndicator(): void {\n    /** @type {CanvasRenderingContext2D} */\n    const { ctx } = this;\n    const shift = this.options.legend.indicatorWidth / 2;\n\n    const isHor = this.isHorizontal();\n    const values = this.ticks;\n    const labelItems = this.getLabelItems();\n    const positions = labelItems\n      ? labelItems.map((el: any) => ({ [isHor ? 'x' : 'y']: el.options.translation[isHor ? 0 : 1] }))\n      : values.map((_, i) => ({ [isHor ? 'x' : 'y']: this.getPixelForTick(i) }));\n\n    ((this as any)._gridLineItems || []).forEach((item: any) => {\n      ctx.save();\n      ctx.strokeStyle = item.color;\n      ctx.lineWidth = item.width;\n\n      if (ctx.setLineDash) {\n        ctx.setLineDash(item.borderDash);\n        ctx.lineDashOffset = item.borderDashOffset;\n      }\n\n      ctx.beginPath();\n\n      if (this.options.grid.drawTicks) {\n        switch (this.options.legend.align) {\n          case 'left':\n            ctx.moveTo(0, item.ty1);\n            ctx.lineTo(shift, item.ty2);\n            break;\n          case 'top':\n            ctx.moveTo(item.tx1, 0);\n            ctx.lineTo(item.tx2, shift);\n            break;\n          case 'bottom':\n            ctx.moveTo(item.tx1, shift);\n            ctx.lineTo(item.tx2, shift * 2);\n            break;\n          default:\n            // right\n            ctx.moveTo(shift, item.ty1);\n            ctx.lineTo(shift * 2, item.ty2);\n            break;\n        }\n      }\n      ctx.stroke();\n      ctx.restore();\n    });\n\n    if (this._model) {\n      const props = this._model;\n      ctx.strokeStyle = props.borderColor;\n      ctx.lineWidth = props.borderWidth || 0;\n      ctx.fillStyle = props.backgroundColor;\n    } else {\n      ctx.fillStyle = 'blue';\n    }\n\n    values.forEach((v, i) => {\n      const pos = positions[i];\n      const radius = this.getSizeForValue(v.value);\n      const x = isHor ? pos.x : shift;\n      const y = isHor ? shift : pos.y;\n      const renderOptions = {\n        pointStyle: 'circle' as const,\n        borderWidth: 0,\n        ...(this._model || {}),\n        radius,\n      };\n      drawPoint(ctx, renderOptions, x, y);\n    });\n  }\n\n  static readonly id = 'size';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [LinearScale.defaults, baseDefaults, scaleDefaults]);\n\n  /**\n   * @hidden\n   */\n  static readonly descriptors = /* #__PURE__ */ {\n    _scriptable: true,\n    _indexable: (name: string): boolean => name !== 'range',\n  };\n}\n\nexport class SizeLogarithmicScale extends LogarithmicLegendScale<ISizeScaleOptions & LogarithmicScaleOptions> {\n  /**\n   * @hidden\n   */\n  _model: PointOptions | null = null;\n\n  /**\n   * @hidden\n   */\n  getSizeForValue(value: number): number {\n    const v = this._getNormalizedValue(value);\n    if (v == null || Number.isNaN(v)) {\n      return this.options.missing;\n    }\n    return this.getSizeImpl(v);\n  }\n\n  /**\n   * @hidden\n   */\n  getSizeImpl(normalized: number): number {\n    return SizeScale.prototype.getSizeImpl.call(this, normalized);\n  }\n\n  /**\n   * @hidden\n   */\n  _drawIndicator(): void {\n    SizeScale.prototype._drawIndicator.call(this);\n  }\n\n  static readonly id = 'sizeLogarithmic';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [LogarithmicScale.defaults, baseDefaults, scaleDefaults]);\n}\n\ndeclare module 'chart.js' {\n  export interface SizeScaleTypeRegistry {\n    size: {\n      options: ISizeScaleOptions & LinearScaleOptions;\n    };\n    sizeLogarithmic: {\n      options: ISizeScaleOptions & LogarithmicScaleOptions;\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  export interface ScaleTypeRegistry extends SizeScaleTypeRegistry {}\n}\n","import {\n  Element,\n  BarElement,\n  BarOptions,\n  VisualElement,\n  Point,\n  ChartType,\n  ScriptableAndArrayOptions,\n  CommonHoverOptions,\n  ScriptableContext,\n} from 'chart.js';\nimport { geoContains, GeoPath, GeoProjection } from 'd3-geo';\nimport type { ProjectionScale } from '../scales';\n\nexport interface IGeoFeatureOptions extends Omit<BarOptions, 'borderWidth'>, Record<string, unknown> {\n  /**\n   * Width of the border\n   * @default 0\n   */\n  borderWidth: number;\n\n  /**\n   * background color for the outline\n   * @default null\n   */\n  outlineBackgroundColor: string | null;\n  /**\n   * border color for the outline\n   * @default defaultColor of Chart.js\n   */\n  outlineBorderColor: string;\n  /**\n   * border width for the outline\n   * @default 0\n   */\n  outlineBorderWidth: number;\n\n  /**\n   * border color for the graticule\n   * @default #CCCCCC\n   */\n  graticuleBorderColor: string;\n  /**\n   * border width for the graticule\n   * @default 0\n   */\n  graticuleBorderWidth: number;\n}\n\nexport type Feature = any;\n\ntype GeoBounds = ReturnType<GeoPath['bounds']>;\n\nfunction growGeoBounds(bounds: GeoBounds, amount: number): GeoBounds {\n  return [\n    [bounds[0][0] - amount, bounds[0][1] - amount],\n    [bounds[1][0] + amount, bounds[1][1] + amount],\n  ];\n}\n\nexport interface IGeoFeatureProps {\n  x: number;\n  y: number;\n}\n\nexport class GeoFeature extends Element<IGeoFeatureProps, IGeoFeatureOptions> implements VisualElement {\n  /**\n   * @hidden\n   */\n  cache?:\n    | {\n        center?: Point;\n        bounds?: {\n          x: number;\n          y: number;\n          width: number;\n          height: number;\n          x2: number;\n          y2: number;\n        };\n        canvasKey?: string;\n        canvas?: HTMLCanvasElement;\n      }\n    | undefined = undefined;\n\n  /**\n   * @hidden\n   */\n  projectionScale!: ProjectionScale;\n\n  /**\n   * @hidden\n   */\n  feature!: Feature;\n\n  /**\n   * @hidden\n   */\n  center?: { longitude: number; latitude: number };\n\n  /**\n   * @hidden\n   */\n  pixelRatio?: number;\n\n  /**\n   * @hidden\n   */\n  inRange(mouseX: number, mouseY: number): boolean {\n    const bb = this.getBounds();\n    const r =\n      (Number.isNaN(mouseX) || (mouseX >= bb.x && mouseX <= bb.x2)) &&\n      (Number.isNaN(mouseY) || (mouseY >= bb.y && mouseY <= bb.y2));\n\n    const projection = this.projectionScale.geoPath.projection() as unknown as GeoProjection;\n    if (r && !Number.isNaN(mouseX) && !Number.isNaN(mouseY) && typeof projection.invert === 'function') {\n      // test for real if within the bounds\n      const longLat = projection.invert([mouseX, mouseY]);\n      return longLat != null && geoContains(this.feature, longLat);\n    }\n\n    return r;\n  }\n\n  /**\n   * @hidden\n   */\n  inXRange(mouseX: number): boolean {\n    return this.inRange(mouseX, Number.NaN);\n  }\n\n  /**\n   * @hidden\n   */\n  inYRange(mouseY: number): boolean {\n    return this.inRange(Number.NaN, mouseY);\n  }\n\n  /**\n   * @hidden\n   */\n  getCenterPoint(): { x: number; y: number } {\n    if (this.cache && this.cache.center) {\n      return this.cache.center;\n    }\n    let center: { x: number; y: number };\n    if (this.center) {\n      const p = this.projectionScale.projection([this.center.longitude, this.center.latitude])!;\n      center = {\n        x: p[0]!,\n        y: p[1]!,\n      };\n    } else {\n      const centroid = this.projectionScale.geoPath.centroid(this.feature);\n      center = {\n        x: centroid[0],\n        y: centroid[1],\n      };\n    }\n    this.cache = { ...(this.cache || {}), center };\n    return center;\n  }\n\n  /**\n   * @hidden\n   */\n  getBounds(): { x: number; y: number; x2: number; y2: number; width: number; height: number } {\n    if (this.cache && this.cache.bounds) {\n      return this.cache.bounds;\n    }\n    const bb = growGeoBounds(this.projectionScale.geoPath.bounds(this.feature), this.options.borderWidth / 2);\n    const bounds = {\n      x: bb[0][0],\n      x2: bb[1][0],\n      y: bb[0][1],\n      y2: bb[1][1],\n      width: bb[1][0] - bb[0][0],\n      height: bb[1][1] - bb[0][1],\n    };\n    this.cache = { ...(this.cache || {}), bounds };\n    return bounds;\n  }\n\n  /**\n   * @hidden\n   */\n  _drawInCache(doc: Document): void {\n    const bounds = this.getBounds();\n    if (!Number.isFinite(bounds.x)) {\n      return;\n    }\n    const canvas = this.cache && this.cache.canvas ? this.cache.canvas : doc.createElement('canvas');\n    const x1 = Math.floor(bounds.x);\n    const y1 = Math.floor(bounds.y);\n    const x2 = Math.ceil(bounds.x + bounds.width);\n    const y2 = Math.ceil(bounds.y + bounds.height);\n    const pixelRatio = this.pixelRatio || 1;\n    const width = Math.ceil(Math.max(x2 - x1, 1) * pixelRatio);\n    const height = Math.ceil(Math.max(y2 - y1, 1) * pixelRatio);\n    if (width <= 0 || height <= 0) {\n      return;\n    }\n    canvas.width = width;\n    canvas.height = height;\n\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.save();\n      ctx.scale(pixelRatio, pixelRatio);\n      ctx.translate(-x1, -y1);\n      this._drawImpl(ctx);\n      ctx.restore();\n\n      this.cache = { ...(this.cache || {}), canvas, canvasKey: this._optionsToKey() };\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  _optionsToKey(): string {\n    const { options } = this;\n    return `${options.backgroundColor};${options.borderColor};${options.borderWidth};${this.pixelRatio}`;\n  }\n\n  /**\n   * @hidden\n   */\n  _drawImpl(ctx: CanvasRenderingContext2D): void {\n    const { feature } = this;\n    const { options } = this;\n    ctx.beginPath();\n    this.projectionScale.geoPath.context(ctx)(feature);\n    if (options.backgroundColor) {\n      ctx.fillStyle = options.backgroundColor;\n      ctx.fill();\n    }\n    if (options.borderColor) {\n      ctx.strokeStyle = options.borderColor;\n      ctx.lineWidth = options.borderWidth as number;\n      ctx.stroke();\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  draw(ctx: CanvasRenderingContext2D): void {\n    const { feature } = this;\n    if (!feature) {\n      return;\n    }\n    if ((!this.cache || this.cache.canvasKey !== this._optionsToKey()) && ctx.canvas.ownerDocument != null) {\n      this._drawInCache(ctx.canvas.ownerDocument);\n    }\n    const bounds = this.getBounds();\n    if (this.cache && this.cache.canvas && this.cache.canvas.width > 0 && this.cache.canvas.height > 0) {\n      const x1 = Math.floor(bounds.x);\n      const y1 = Math.floor(bounds.y);\n      const x2 = Math.ceil(bounds.x + bounds.width);\n      const y2 = Math.ceil(bounds.y + bounds.height);\n      const width = x2 - x1;\n      const height = y2 - y1;\n      if (width > 0 && height > 0) {\n        ctx.drawImage(this.cache.canvas, x1, y1, x2 - x1, y2 - y1);\n      }\n    } else if (Number.isFinite(bounds.x)) {\n      ctx.save();\n      this._drawImpl(ctx);\n      ctx.restore();\n    }\n  }\n\n  static id = 'geoFeature';\n\n  /**\n   * @hidden\n   */\n  static defaults = /* #__PURE__ */ {\n    ...BarElement.defaults,\n    outlineBackgroundColor: null,\n    outlineBorderWidth: 0,\n\n    graticuleBorderColor: '#CCCCCC',\n    graticuleBorderWidth: 0,\n  };\n\n  /**\n   * @hidden\n   */\n  static defaultRoutes = /* #__PURE__ */ {\n    outlineBorderColor: 'borderColor',\n    ...(BarElement.defaultRoutes || {}),\n  };\n}\n\ndeclare module 'chart.js' {\n  export interface ElementOptionsByType<TType extends ChartType> {\n    geoFeature: ScriptableAndArrayOptions<IGeoFeatureOptions & CommonHoverOptions, ScriptableContext<TType>>;\n  }\n}\n","import {\n  DatasetController,\n  ChartDataset,\n  ScriptableAndArrayOptions,\n  UpdateMode,\n  Element,\n  VisualElement,\n  ScriptableContext,\n  ChartTypeRegistry,\n  AnimationOptions,\n} from 'chart.js';\nimport { clipArea, unclipArea, valueOrDefault } from 'chart.js/helpers';\nimport { geoGraticule, geoGraticule10, ExtendedFeature } from 'd3-geo';\nimport { ProjectionScale } from '../scales';\nimport type { GeoFeature, IGeoFeatureOptions } from '../elements';\n\nexport const geoDefaults = {\n  showOutline: false,\n  showGraticule: false,\n  clipMap: true,\n};\n\nexport const geoOverrides = {\n  scales: {\n    projection: {\n      axis: 'x',\n      type: ProjectionScale.id,\n      position: 'chartArea',\n      display: false,\n    },\n  },\n};\n\nfunction patchDatasetElementOptions(options: any) {\n  // patch the options by removing the `outline` or `hoverOutline` option;\n  // see https://github.com/chartjs/Chart.js/issues/7362\n  const r: any = { ...options };\n  Object.keys(options).forEach((key) => {\n    let targetKey = key;\n    if (key.startsWith('outline')) {\n      const sub = key.slice('outline'.length);\n      targetKey = sub[0].toLowerCase() + sub.slice(1);\n    } else if (key.startsWith('hoverOutline')) {\n      targetKey = `hover${key.slice('hoverOutline'.length)}`;\n    } else {\n      return;\n    }\n    delete r[key];\n    r[targetKey] = options[key];\n  });\n  return r;\n}\n\nexport class GeoController<\n  TYPE extends keyof ChartTypeRegistry,\n  TElement extends Element & VisualElement,\n> extends DatasetController<TYPE, TElement, GeoFeature> {\n  getGeoDataset(): ChartDataset<'choropleth' | 'bubbleMap'> & IGeoControllerDatasetOptions {\n    return super.getDataset() as unknown as ChartDataset<'choropleth' | 'bubbleMap'> & IGeoControllerDatasetOptions;\n  }\n\n  getGeoOptions(): IGeoChartOptions {\n    return this.chart.options as unknown as IGeoChartOptions;\n  }\n\n  getProjectionScale(): ProjectionScale {\n    return this.getScaleForId('projection') as ProjectionScale;\n  }\n\n  linkScales(): void {\n    const dataset = this.getGeoDataset();\n    const meta = this.getMeta();\n    meta.xAxisID = 'projection';\n    dataset.xAxisID = 'projection';\n    meta.yAxisID = 'projection';\n    dataset.yAxisID = 'projection';\n    meta.xScale = this.getScaleForId('projection');\n    meta.yScale = this.getScaleForId('projection');\n\n    this.getProjectionScale().computeBounds(this.resolveOutline());\n  }\n\n  showOutline(): IGeoChartOptions['showOutline'] {\n    return valueOrDefault(this.getGeoDataset().showOutline, this.getGeoOptions().showOutline);\n  }\n\n  clipMap(): IGeoChartOptions['clipMap'] {\n    return valueOrDefault(this.getGeoDataset().clipMap, this.getGeoOptions().clipMap);\n  }\n\n  getGraticule(): IGeoChartOptions['showGraticule'] {\n    return valueOrDefault(this.getGeoDataset().showGraticule, this.getGeoOptions().showGraticule);\n  }\n\n  update(mode: UpdateMode): void {\n    super.update(mode);\n\n    const meta = this.getMeta();\n\n    const scale = this.getProjectionScale();\n    const dirtyCache = scale.updateBounds();\n\n    if (this.showOutline()) {\n      const elem = meta.dataset!;\n      if (dirtyCache) {\n        delete elem.cache;\n      }\n      elem.projectionScale = scale;\n      elem.pixelRatio = this.chart.currentDevicePixelRatio;\n      if (mode !== 'resize') {\n        const options = patchDatasetElementOptions(this.resolveDatasetElementOptions(mode));\n        const properties = {\n          feature: this.resolveOutline(),\n          options,\n        };\n        this.updateElement(elem, undefined, properties, mode);\n        if (this.getGraticule()) {\n          (meta as any).graticule = options;\n        }\n      }\n    } else if (this.getGraticule() && mode !== 'resize') {\n      (meta as any).graticule = patchDatasetElementOptions(this.resolveDatasetElementOptions(mode));\n    }\n\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n    if (dirtyCache) {\n      meta.data.forEach((elem) => delete (elem as any).cache);\n    }\n  }\n\n  resolveOutline(): any {\n    const ds = this.getGeoDataset();\n    const outline = ds.outline || { type: 'Sphere' };\n    if (Array.isArray(outline)) {\n      return {\n        type: 'FeatureCollection',\n        features: outline,\n      };\n    }\n    return outline;\n  }\n\n  showGraticule(): void {\n    const g = this.getGraticule();\n    const options = (this.getMeta() as any).graticule;\n    if (!g || !options) {\n      return;\n    }\n    const { ctx } = this.chart;\n    const scale = this.getProjectionScale();\n    const path = scale.geoPath.context(ctx);\n\n    ctx.save();\n    ctx.beginPath();\n\n    if (typeof g === 'boolean') {\n      if (g) {\n        path(geoGraticule10());\n      }\n    } else {\n      const geo = geoGraticule();\n      if (g.stepMajor) {\n        geo.stepMajor(g.stepMajor as unknown as [number, number]);\n      }\n      if (g.stepMinor) {\n        geo.stepMinor(g.stepMinor as unknown as [number, number]);\n      }\n      path(geo());\n    }\n\n    ctx.strokeStyle = options.graticuleBorderColor;\n    ctx.lineWidth = options.graticuleBorderWidth;\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  draw(): void {\n    const { chart } = this;\n\n    const clipMap = this.clipMap();\n\n    // enable clipping based on the option\n    let enabled = false;\n    if (clipMap === true || clipMap === 'outline' || clipMap === 'outline+graticule') {\n      enabled = true;\n      clipArea(chart.ctx, chart.chartArea);\n    }\n\n    if (this.showOutline() && this.getMeta().dataset) {\n      (this.getMeta().dataset!.draw.call as any)(this.getMeta().dataset!, chart.ctx, chart.chartArea);\n    }\n\n    if (clipMap === true || clipMap === 'graticule' || clipMap === 'outline+graticule') {\n      if (!enabled) {\n        clipArea(chart.ctx, chart.chartArea);\n      }\n    } else if (enabled) {\n      enabled = false;\n      unclipArea(chart.ctx);\n    }\n\n    this.showGraticule();\n\n    if (clipMap === true || clipMap === 'items') {\n      if (!enabled) {\n        clipArea(chart.ctx, chart.chartArea);\n      }\n    } else if (enabled) {\n      enabled = false;\n      unclipArea(chart.ctx);\n    }\n\n    this.getMeta().data.forEach((elem) => (elem.draw.call as any)(elem, chart.ctx, chart.chartArea));\n\n    if (enabled) {\n      enabled = false;\n      unclipArea(chart.ctx);\n    }\n  }\n}\n\nexport interface IGeoChartOptions {\n  /**\n   * Outline used to scale and centralize the projection in the chart area.\n   * By default a sphere is used\n   * @default { type: 'Sphere\" }\n   */\n  outline: any[];\n  /**\n   * option to render the outline in the background, see also the outline... styling option\n   * @default false\n   */\n  showOutline: boolean;\n\n  /**\n   * option to render a graticule in the background, see also the outline... styling option\n   * @default false\n   */\n  showGraticule:\n    | boolean\n    | {\n        stepMajor: [number, number];\n        stepMinor: [number, number];\n      };\n\n  /**\n   * option whether to clip the rendering to the chartArea of the graph\n   * @default choropleth: true bubbleMap: 'outline+graticule'\n   */\n  clipMap: boolean | 'outline' | 'graticule' | 'outline+graticule' | 'items';\n}\n\nexport interface IGeoControllerDatasetOptions\n  extends IGeoChartOptions,\n    ScriptableAndArrayOptions<IGeoFeatureOptions, ScriptableContext<'choropleth' | 'bubbleMap'>>,\n    AnimationOptions<'choropleth' | 'bubbleMap'> {\n  xAxisID?: string;\n  yAxisID?: string;\n  rAxisID?: string;\n  iAxisID?: string;\n  vAxisID?: string;\n}\n\nexport interface IGeoDataPoint {\n  feature: ExtendedFeature;\n  center?: {\n    longitude: number;\n    latitude: number;\n  };\n}\n","import { registry, DatasetControllerChartComponent, ChartComponent } from 'chart.js';\n\nexport default function patchController<T, TYPE>(\n  type: TYPE,\n  config: T,\n  controller: DatasetControllerChartComponent,\n  elements: ChartComponent | ChartComponent[] = [],\n  scales: ChartComponent | ChartComponent[] = []\n): T & { type: TYPE } {\n  registry.addControllers(controller);\n  if (Array.isArray(elements)) {\n    registry.addElements(...elements);\n  } else {\n    registry.addElements(elements);\n  }\n  if (Array.isArray(scales)) {\n    registry.addScales(...scales);\n  } else {\n    registry.addScales(scales);\n  }\n  const c = config as any;\n  c.type = type;\n  return c;\n}\n","import {\n  Chart,\n  UpdateMode,\n  ScriptableContext,\n  TooltipItem,\n  CommonHoverOptions,\n  ScriptableAndArrayOptions,\n  ControllerDatasetOptions,\n  ChartConfiguration,\n  ChartItem,\n  PointOptions,\n  Scale,\n  AnimationOptions,\n} from 'chart.js';\nimport { merge } from 'chart.js/helpers';\nimport { geoDefaults, GeoController, IGeoChartOptions, IGeoDataPoint, geoOverrides } from './GeoController';\nimport { GeoFeature, IGeoFeatureOptions, IGeoFeatureProps } from '../elements';\nimport { ColorScale, ProjectionScale } from '../scales';\nimport patchController from './patchController';\n\nexport class ChoroplethController extends GeoController<'choropleth', GeoFeature> {\n  initialize(): void {\n    super.initialize();\n    this.enableOptionSharing = true;\n  }\n\n  linkScales(): void {\n    super.linkScales();\n    const dataset = this.getGeoDataset();\n    const meta = this.getMeta();\n    meta.vAxisID = 'color';\n    meta.rAxisID = 'color';\n    dataset.vAxisID = 'color';\n    dataset.rAxisID = 'color';\n    meta.rScale = this.getScaleForId('color');\n    meta.vScale = meta.rScale;\n    meta.iScale = meta.xScale;\n\n    meta.iAxisID = meta.xAxisID!;\n\n    dataset.iAxisID = meta.xAxisID!;\n  }\n\n  _getOtherScale(scale: Scale): Scale {\n    // for strange get min max with other scale\n    return scale;\n  }\n\n  parse(start: number, count: number): void {\n    const rScale = this.getMeta().rScale!;\n    const { data } = this.getDataset();\n    const meta = this._cachedMeta;\n    for (let i = start; i < start + count; i += 1) {\n      meta._parsed[i] = {\n        [rScale.axis]: rScale.parse(data[i], i),\n      };\n    }\n  }\n\n  updateElements(elems: GeoFeature[], start: number, count: number, mode: UpdateMode): void {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n\n    const sharedOptions = this.getSharedOptions(firstOpts)!;\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const scale = this.getProjectionScale();\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n\n    for (let i = start; i < start + count; i += 1) {\n      const elem = elems[i];\n      elem.projectionScale = scale;\n      elem.feature = (this as any)._data[i].feature;\n      elem.center = (this as any)._data[i].center;\n      elem.pixelRatio = this.chart.currentDevicePixelRatio;\n      const center = elem.getCenterPoint();\n\n      const properties: IGeoFeatureProps & { options?: PointOptions } = {\n        x: center.x,\n        y: center.y,\n      };\n      if (includeOptions) {\n        properties.options = (sharedOptions || this.resolveDataElementOptions(i, mode)) as unknown as PointOptions;\n      }\n      this.updateElement(elem, i, properties as unknown as Record<string, unknown>, mode);\n    }\n  }\n\n  indexToColor(index: number): string {\n    const rScale = this.getMeta().rScale as unknown as ColorScale;\n    return rScale.getColorForValue(this.getParsed(index)[rScale.axis as 'r']);\n  }\n\n  static readonly id = 'choropleth';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [\n    geoDefaults,\n    {\n      datasetElementType: GeoFeature.id,\n      dataElementType: GeoFeature.id,\n    },\n  ]);\n\n  /**\n   * @hidden\n   */\n  static readonly overrides: any = /* #__PURE__ */ merge({}, [\n    geoOverrides,\n    {\n      plugins: {\n        tooltip: {\n          callbacks: {\n            title() {\n              // Title doesn't make sense for scatter since we format the data as a point\n              return '';\n            },\n            label(item: TooltipItem<'choropleth'>) {\n              if (item.formattedValue == null) {\n                return item.chart.data?.labels?.[item.dataIndex];\n              }\n              return `${item.chart.data?.labels?.[item.dataIndex]}: ${item.formattedValue}`;\n            },\n          },\n        },\n        colors: {\n          enabled: false,\n        },\n      },\n      scales: {\n        color: {\n          type: ColorScale.id,\n          axis: 'x',\n        },\n      },\n      elements: {\n        geoFeature: {\n          backgroundColor(context: ScriptableContext<'choropleth'>) {\n            if (context.dataIndex == null) {\n              return null;\n            }\n            const controller = (context.chart as Chart<'choropleth'>).getDatasetMeta(context.datasetIndex)\n              .controller as ChoroplethController;\n            return controller.indexToColor(context.dataIndex);\n          },\n        },\n      },\n    },\n  ]);\n}\n\nexport interface IChoroplethControllerDatasetOptions\n  extends ControllerDatasetOptions,\n    IGeoChartOptions,\n    ScriptableAndArrayOptions<IGeoFeatureOptions, ScriptableContext<'choropleth'>>,\n    ScriptableAndArrayOptions<CommonHoverOptions, ScriptableContext<'choropleth'>>,\n    AnimationOptions<'choropleth'> {}\n\nexport interface IChoroplethDataPoint extends IGeoDataPoint {\n  value: number;\n}\n\ndeclare module 'chart.js' {\n  export interface ChartTypeRegistry {\n    choropleth: {\n      chartOptions: IGeoChartOptions;\n      datasetOptions: IChoroplethControllerDatasetOptions;\n      defaultDataPoint: IChoroplethDataPoint;\n      scales: keyof (ProjectionScaleTypeRegistry & ColorScaleTypeRegistry);\n      metaExtensions: Record<string, never>;\n      parsedDataType: { r: number };\n    };\n  }\n}\n\nexport class ChoroplethChart<DATA extends unknown[] = IGeoDataPoint[], LABEL = string> extends Chart<\n  'choropleth',\n  DATA,\n  LABEL\n> {\n  static id = ChoroplethController.id;\n\n  constructor(item: ChartItem, config: Omit<ChartConfiguration<'choropleth', DATA, LABEL>, 'type'>) {\n    super(item, patchController('choropleth', config, ChoroplethController, GeoFeature, [ColorScale, ProjectionScale]));\n  }\n}\n","import {\n  Chart,\n  ChartItem,\n  ChartConfiguration,\n  CommonHoverOptions,\n  ControllerDatasetOptions,\n  PointOptions,\n  PointProps,\n  ScriptableContext,\n  TooltipItem,\n  PointElement,\n  PointHoverOptions,\n  Element,\n  Scale,\n  ScriptableAndArrayOptions,\n  UpdateMode,\n  AnimationOptions,\n} from 'chart.js';\nimport { merge } from 'chart.js/helpers';\nimport { GeoFeature, IGeoFeatureOptions } from '../elements';\nimport { ProjectionScale, SizeScale } from '../scales';\nimport { GeoController, geoDefaults, geoOverrides, IGeoChartOptions } from './GeoController';\nimport patchController from './patchController';\n\ntype MyPointElement = PointElement & Element<PointProps, PointOptions & PointHoverOptions & Record<string, unknown>>;\n\nexport class BubbleMapController extends GeoController<'bubbleMap', MyPointElement> {\n  initialize(): void {\n    super.initialize();\n    this.enableOptionSharing = true;\n  }\n\n  linkScales(): void {\n    super.linkScales();\n    const dataset = this.getGeoDataset();\n    const meta = this.getMeta();\n    meta.vAxisID = 'size';\n    meta.rAxisID = 'size';\n    dataset.vAxisID = 'size';\n    dataset.rAxisID = 'size';\n    meta.rScale = this.getScaleForId('size');\n    meta.vScale = meta.rScale;\n    meta.iScale = meta.xScale;\n\n    meta.iAxisID = meta.xAxisID!;\n\n    dataset.iAxisID = meta.xAxisID!;\n  }\n\n  _getOtherScale(scale: Scale): Scale {\n    // for strange get min max with other scale\n    return scale;\n  }\n\n  parse(start: number, count: number): void {\n    const rScale = this.getMeta().rScale!;\n    const data = this.getDataset().data as unknown as IBubbleMapDataPoint[];\n    const meta = this._cachedMeta;\n    for (let i = start; i < start + count; i += 1) {\n      const d = data[i];\n      meta._parsed[i] = {\n        x: d.longitude == null ? d.x : d.longitude,\n        y: d.latitude == null ? d.y : d.latitude,\n        [rScale.axis]: rScale.parse(d, i),\n      };\n    }\n  }\n\n  updateElements(elems: MyPointElement[], start: number, count: number, mode: UpdateMode): void {\n    const reset = mode === 'reset';\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n\n    const sharedOptions = this.getSharedOptions(firstOpts)!;\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const scale = this.getProjectionScale();\n\n    (this.getMeta().rScale as unknown as SizeScale)._model = firstOpts as unknown as PointOptions; // for legend rendering styling\n\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n\n    for (let i = start; i < start + count; i += 1) {\n      const elem = elems[i];\n      const parsed = this.getParsed(i);\n      const projection = scale.projection([parsed.x, parsed.y]);\n      const properties: PointProps & { options?: PointOptions; skip: boolean } = {\n        x: projection ? projection[0] : 0,\n        y: projection ? projection[1] : 0,\n        skip: Number.isNaN(parsed.x) || Number.isNaN(parsed.y),\n      };\n      if (includeOptions) {\n        properties.options = (sharedOptions || this.resolveDataElementOptions(i, mode)) as unknown as PointOptions;\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n      this.updateElement(elem, i, properties as unknown as Record<string, unknown>, mode);\n    }\n  }\n\n  indexToRadius(index: number): number {\n    const rScale = this.getMeta().rScale as SizeScale;\n    return rScale.getSizeForValue(this.getParsed(index)[rScale.axis as 'r']);\n  }\n\n  static readonly id = 'bubbleMap';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [\n    geoDefaults,\n    {\n      dataElementType: PointElement.id,\n      datasetElementType: GeoFeature.id,\n      showOutline: true,\n      clipMap: 'outline+graticule',\n    },\n  ]);\n\n  /**\n   * @hidden\n   */\n  static readonly overrides: any = /* #__PURE__ */ merge({}, [\n    geoOverrides,\n    {\n      plugins: {\n        tooltip: {\n          callbacks: {\n            title() {\n              // Title doesn't make sense for scatter since we format the data as a point\n              return '';\n            },\n            label(item: TooltipItem<'bubbleMap'>) {\n              if (item.formattedValue == null) {\n                return item.chart.data?.labels?.[item.dataIndex];\n              }\n              return `${item.chart.data?.labels?.[item.dataIndex]}: ${item.formattedValue}`;\n            },\n          },\n        },\n      },\n      scales: {\n        size: {\n          axis: 'x',\n          type: SizeScale.id,\n        },\n      },\n      elements: {\n        point: {\n          radius(context: ScriptableContext<'bubbleMap'>) {\n            if (context.dataIndex == null) {\n              return null;\n            }\n            const controller = (context.chart as Chart<'bubbleMap'>).getDatasetMeta(context.datasetIndex)\n              .controller as BubbleMapController;\n            return controller.indexToRadius(context.dataIndex);\n          },\n          hoverRadius(context: ScriptableContext<'bubbleMap'>) {\n            if (context.dataIndex == null) {\n              return null;\n            }\n            const controller = (context.chart as Chart<'bubbleMap'>).getDatasetMeta(context.datasetIndex)\n              .controller as BubbleMapController;\n            return controller.indexToRadius(context.dataIndex) + 1;\n          },\n        },\n      },\n    },\n  ]);\n}\n\nexport interface IBubbleMapDataPoint {\n  longitude: number;\n  latitude: number;\n  x?: number;\n  y?: number;\n  value: number;\n}\n\nexport interface IBubbleMapControllerDatasetOptions\n  extends ControllerDatasetOptions,\n    IGeoChartOptions,\n    ScriptableAndArrayOptions<IGeoFeatureOptions, ScriptableContext<'bubbleMap'>>,\n    ScriptableAndArrayOptions<CommonHoverOptions, ScriptableContext<'bubbleMap'>>,\n    AnimationOptions<'bubbleMap'> {}\n\ndeclare module 'chart.js' {\n  export interface ChartTypeRegistry {\n    bubbleMap: {\n      chartOptions: IGeoChartOptions;\n      datasetOptions: IBubbleMapControllerDatasetOptions;\n      defaultDataPoint: IBubbleMapDataPoint;\n      scales: keyof (ProjectionScaleTypeRegistry & SizeScaleTypeRegistry);\n      metaExtensions: Record<string, never>;\n      parsedDataType: { r: number; x: number; y: number };\n    };\n  }\n}\n\nexport class BubbleMapChart<DATA extends unknown[] = IBubbleMapDataPoint[], LABEL = string> extends Chart<\n  'bubbleMap',\n  DATA,\n  LABEL\n> {\n  static id = BubbleMapController.id;\n\n  constructor(item: ChartItem, config: Omit<ChartConfiguration<'bubbleMap', DATA, LABEL>, 'type'>) {\n    super(item, patchController('bubbleMap', config, BubbleMapController, GeoFeature, [SizeScale, ProjectionScale]));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}